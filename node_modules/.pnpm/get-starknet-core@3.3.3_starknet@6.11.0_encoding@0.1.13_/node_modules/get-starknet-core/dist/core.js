var Z = Object.defineProperty;
var X = (t, e, n) => e in t ? Z(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n;
var F = (t, e, n) => (X(t, typeof e != "symbol" ? e + "" : e, n), n), B = (t, e, n) => {
  if (!e.has(t))
    throw TypeError("Cannot " + n);
};
var N = (t, e, n) => (B(t, e, "read from private field"), n ? n.call(t) : e.get(t)), L = (t, e, n) => {
  if (e.has(t))
    throw TypeError("Cannot add the same private member more than once");
  e instanceof WeakSet ? e.add(t) : e.set(t, n);
}, $ = (t, e, n, r) => (B(t, e, "write to private field"), r ? r.call(t, n) : e.set(t, n), n);
var P = (t, e, n) => (B(t, e, "access private method"), n);
const generateUID = () => `${Date.now()}-${Math.floor(Math.random() * 8999999999999) + 1e12}`, shuffle = (t) => {
  for (let e = t.length - 1; e > 0; e--) {
    const n = Math.floor(Math.random() * (e + 1));
    [t[e], t[n]] = [t[n], t[e]];
  }
  return t;
};
function pipe$1(...t) {
  return (e) => t.reduce((n, r) => n.then(r), Promise.resolve(e));
}
const ssrSafeWindow = typeof window < "u" ? window : null;
var Y, V;
const wallets = [
  {
    id: "argentX",
    name: "Argent X",
    icon: "data:image/svg+xml;base64,Cjxzdmcgd2lkdGg9IjQwIiBoZWlnaHQ9IjM2IiB2aWV3Qm94PSIwIDAgNDAgMzYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxwYXRoIGQ9Ik0yNC43NTgyIC0zLjk3MzY0ZS0wN0gxNC42MjM4QzE0LjI4NTEgLTMuOTczNjRlLTA3IDE0LjAxMzggMC4yODExNzggMTQuMDA2NCAwLjYzMDY4M0MxMy44MDE3IDEwLjQ1NDkgOC44MjIzNCAxOS43NzkyIDAuMjUxODkzIDI2LjM4MzdDLTAuMDIwMjA0NiAyNi41OTMzIC0wLjA4MjE5NDYgMjYuOTg3MiAwLjExNjczNCAyNy4yNzA5TDYuMDQ2MjMgMzUuNzM0QzYuMjQ3OTYgMzYuMDIyIDYuNjQwOTkgMzYuMDg3IDYuOTE3NjYgMzUuODc1NEMxMi4yNzY1IDMxLjc3MjggMTYuNTg2OSAyNi44MjM2IDE5LjY5MSAyMS4zMzhDMjIuNzk1MSAyNi44MjM2IDI3LjEwNTcgMzEuNzcyOCAzMi40NjQ2IDM1Ljg3NTRDMzIuNzQxIDM2LjA4NyAzMy4xMzQxIDM2LjAyMiAzMy4zMzYxIDM1LjczNEwzOS4yNjU2IDI3LjI3MDlDMzkuNDY0MiAyNi45ODcyIDM5LjQwMjIgMjYuNTkzMyAzOS4xMzA0IDI2LjM4MzdDMzAuNTU5NyAxOS43NzkyIDI1LjU4MDQgMTAuNDU0OSAyNS4zNzU5IDAuNjMwNjgzQzI1LjM2ODUgMC4yODExNzggMjUuMDk2OSAtMy45NzM2NGUtMDcgMjQuNzU4MiAtMy45NzM2NGUtMDdaIiBmaWxsPSIjRkY4NzVCIi8+Cjwvc3ZnPgo=",
    downloads: {
      chrome: "https://chrome.google.com/webstore/detail/argent-x-starknet-wallet/dlcobpjiigpikoobohmabehhmhfoodbb",
      firefox: "https://addons.mozilla.org/en-US/firefox/addon/argent-x",
      edge: "https://microsoftedge.microsoft.com/addons/detail/argent-x/ajcicjlkibolbeaaagejfhnofogocgcj"
    }
  },
  {
    id: "braavos",
    name: "Braavos",
    icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgdmlld0JveD0iMCAwIDEwMCAxMDAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CiAgICA8cGF0aAogICAgICAgIGQ9Ik02Mi43MDUgMTMuOTExNkM2Mi44MzU5IDE0LjEzMzMgNjIuNjYyMSAxNC40MDcgNjIuNDAzOSAxNC40MDdDNTcuMTgwNyAxNC40MDcgNTIuOTM0OCAxOC41NDI3IDUyLjgzNTEgMjMuNjgxN0M1MS4wNDY1IDIzLjM0NzcgNDkuMTkzMyAyMy4zMjI2IDQ3LjM2MjYgMjMuNjMxMUM0Ny4yMzYxIDE4LjUxNTYgNDMuMDAwOSAxNC40MDcgMzcuNzk0OCAxNC40MDdDMzcuNTM2NSAxNC40MDcgMzcuMzYyNSAxNC4xMzMxIDM3LjQ5MzUgMTMuOTExMkM0MC4wMjE3IDkuNjI4MDkgNDQuNzIwNCA2Ljc1IDUwLjA5OTEgNi43NUM1NS40NzgxIDYuNzUgNjAuMTc2OSA5LjYyODI2IDYyLjcwNSAxMy45MTE2WiIKICAgICAgICBmaWxsPSJ1cmwoI3BhaW50MF9saW5lYXJfMzcyXzQwMjU5KSIgLz4KICAgIDxwYXRoCiAgICAgICAgZD0iTTc4Ljc2MDYgNDUuODcxOEM4MC4yNzI1IDQ2LjMyOTcgODEuNzAyNSA0NS4wMDU1IDgxLjE3MTQgNDMuNTIyMkM3Ni40MTM3IDMwLjIzMzQgNjEuMzkxMSAyNC44MDM5IDUwLjAyNzcgMjQuODAzOUMzOC42NDQyIDI0LjgwMzkgMjMuMjg2OCAzMC40MDcgMTguODc1NCA0My41OTEyQzE4LjM4MjQgNDUuMDY0NSAxOS44MDgzIDQ2LjM0NDYgMjEuMjk3OCA0NS44ODgxTDQ4Ljg3MiAzNy40MzgxQzQ5LjUzMzEgMzcuMjM1NSA1MC4yMzk5IDM3LjIzNDQgNTAuOTAxNyAzNy40MzQ4TDc4Ljc2MDYgNDUuODcxOFoiCiAgICAgICAgZmlsbD0idXJsKCNwYWludDFfbGluZWFyXzM3Ml80MDI1OSkiIC8+CiAgICA8cGF0aAogICAgICAgIGQ9Ik0xOC44MTMyIDQ4LjE3MDdMNDguODkzNSAzOS4wNDcyQzQ5LjU1MDYgMzguODQ3OCA1MC4yNTI0IDM4Ljg0NzMgNTAuOTA5OCAzOS4wNDU2TDgxLjE3ODEgNDguMTc1MkM4My42OTEyIDQ4LjkzMzIgODUuNDExIDUxLjI0ODMgODUuNDExIDUzLjg3MzVWODEuMjIzM0M4NS4yOTQ0IDg3Ljg5OTEgNzkuMjk3NyA5My4yNSA3Mi42MjQ1IDkzLjI1SDYxLjU0MDZDNjAuNDQ0OSA5My4yNSA1OS41NTc3IDkyLjM2MzcgNTkuNTU3NyA5MS4yNjhWODEuNjc4OUM1OS41NTc3IDc3LjkwMzEgNjEuNzkyMSA3NC40ODU1IDY1LjI0OTggNzIuOTcyOUM2OS44ODQ5IDcwLjk0NTQgNzUuMzY4MSA2OC4yMDI4IDc2LjM5OTQgNjIuNjk5MkM3Ni43MzIzIDYwLjkyMjkgNzUuNTc0MSA1OS4yMDk0IDczLjgwMjQgNTguODU3M0M2OS4zMjI2IDU3Ljk2NjcgNjQuMzU2MiA1OC4zMTA3IDYwLjE1NjQgNjAuMTg5M0M1NS4zODg3IDYyLjMyMTkgNTQuMTQxNSA2NS44Njk0IDUzLjY3OTcgNzAuNjMzN0w1My4xMjAxIDc1Ljc2NjJDNTIuOTQ5MSA3Ny4zMzQ5IDUxLjQ3ODUgNzguNTM2NiA0OS45MDE0IDc4LjUzNjZDNDguMjY5OSA3OC41MzY2IDQ3LjA0NjUgNzcuMjk0IDQ2Ljg2OTYgNzUuNjcxMkw0Ni4zMjA0IDcwLjYzMzdDNDUuOTI0OSA2Ni41NTI5IDQ1LjIwNzkgNjIuNTg4NyA0MC45ODk1IDYwLjcwMThDMzYuMTc3NiA1OC41NDk0IDMxLjM0MTkgNTcuODM0NyAyNi4xOTc2IDU4Ljg1NzNDMjQuNDI2IDU5LjIwOTQgMjMuMjY3OCA2MC45MjI5IDIzLjYwMDcgNjIuNjk5MkMyNC42NDEgNjguMjUwNyAzMC4wODEyIDcwLjkzMDUgMzQuNzUwMyA3Mi45NzI5QzM4LjIwOCA3NC40ODU1IDQwLjQ0MjQgNzcuOTAzMSA0MC40NDI0IDgxLjY3ODlWOTEuMjY2M0M0MC40NDI0IDkyLjM2MiAzOS41NTU1IDkzLjI1IDM4LjQ1OTkgOTMuMjVIMjcuMzc1NkMyMC43MDI0IDkzLjI1IDE0LjcwNTcgODcuODk5MSAxNC41ODkxIDgxLjIyMzNWNTMuODY2M0MxNC41ODkxIDUxLjI0NDYgMTYuMzA0NSA0OC45MzE2IDE4LjgxMzIgNDguMTcwN1oiCiAgICAgICAgZmlsbD0idXJsKCNwYWludDJfbGluZWFyXzM3Ml80MDI1OSkiIC8+CiAgICA8ZGVmcz4KICAgICAgICA8bGluZWFyR3JhZGllbnQgaWQ9InBhaW50MF9saW5lYXJfMzcyXzQwMjU5IiB4MT0iNDkuMzA1NyIgeTE9IjIuMDc5IiB4Mj0iODAuMzYyNyIgeTI9IjkzLjY1OTciCiAgICAgICAgICAgIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KICAgICAgICAgICAgPHN0b3Agc3RvcC1jb2xvcj0iI0Y1RDQ1RSIgLz4KICAgICAgICAgICAgPHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjRkY5NjAwIiAvPgogICAgICAgIDwvbGluZWFyR3JhZGllbnQ+CiAgICAgICAgPGxpbmVhckdyYWRpZW50IGlkPSJwYWludDFfbGluZWFyXzM3Ml80MDI1OSIgeDE9IjQ5LjMwNTciIHkxPSIyLjA3OSIgeDI9IjgwLjM2MjciIHkyPSI5My42NTk3IgogICAgICAgICAgICBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+CiAgICAgICAgICAgIDxzdG9wIHN0b3AtY29sb3I9IiNGNUQ0NUUiIC8+CiAgICAgICAgICAgIDxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iI0ZGOTYwMCIgLz4KICAgICAgICA8L2xpbmVhckdyYWRpZW50PgogICAgICAgIDxsaW5lYXJHcmFkaWVudCBpZD0icGFpbnQyX2xpbmVhcl8zNzJfNDAyNTkiIHgxPSI0OS4zMDU3IiB5MT0iMi4wNzkiIHgyPSI4MC4zNjI3IiB5Mj0iOTMuNjU5NyIKICAgICAgICAgICAgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPgogICAgICAgICAgICA8c3RvcCBzdG9wLWNvbG9yPSIjRjVENDVFIiAvPgogICAgICAgICAgICA8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiNGRjk2MDAiIC8+CiAgICAgICAgPC9saW5lYXJHcmFkaWVudD4KICAgIDwvZGVmcz4KPC9zdmc+",
    downloads: {
      chrome: "https://chrome.google.com/webstore/detail/braavos-wallet/jnlgamecbpmbajjfhmmmlhejkemejdma",
      firefox: "https://addons.mozilla.org/en-US/firefox/addon/braavos-wallet",
      edge: "https://microsoftedge.microsoft.com/addons/detail/braavos-wallet/hkkpjehhcnhgefhbdcgfkeegglpjchdc",
      ios: `https://link.braavos.app/dapp/${(Y = ssrSafeWindow == null ? void 0 : ssrSafeWindow.location) == null ? void 0 : Y.host}`,
      android: `https://link.braavos.app/dapp/${(V = ssrSafeWindow == null ? void 0 : ssrSafeWindow.location) == null ? void 0 : V.host}`
    }
  },
  {
    id: "okxwallet",
    name: "OKX Wallet",
    icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAJDSURBVHgB7Zq9jtpAEMfHlhEgQLiioXEkoAGECwoKxMcTRHmC5E3IoyRPkPAEkI7unJYmTgEFTYwA8a3NTKScLnCHN6c9r1e3P2llWQy7M/s1Gv1twCP0ej37dDq9x+Zut1t3t9vZjDEHIiSRSPg4ZpDL5fxkMvn1cDh8m0wmfugfO53OoFQq/crn8wxfY9EymQyrVCqMfHvScZx1p9ls3pFxXBy/bKlUipGPrVbLuQqAfsCliq3zl0H84zwtjQrOw4Mt1W63P5LvBm2d+Xz+YzqdgkqUy+WgWCy+Mc/nc282m4FqLBYL+3g8fjDxenq72WxANZbLJeA13zDX67UDioL5ybXwafMYu64Ltn3bdDweQ5R97fd7GyhBQMipx4POeEDHIu2LfDdBIGGz+hJ9CQ1ABjoA2egAZPM6AgiCAEQhsi/C4jHyPA/6/f5NG3Ks2+3CYDC4aTccDrn6ojG54MnEvG00GoVmWLIRNZ7wTCwDHYBsdACy0QHIhiuRETxlICWpMMhGZHmqS8qH6JLyGegAZKMDkI0uKf8X4SWlaZo+Pp1bRrwlJU8ZKLIvUjKh0WiQ3sRUbNVq9c5Ebew7KEo2m/1p4jJ4qAmDaqDQBzj5XyiAT4VCQezJigAU+IDU+z8vJFnGWeC+bKQV/5VZ71FV6L7PA3gg3tXrdQ+DgLhC+75Wq3no69P3MC0NFQpx2lL04Ql9gHK1bRDjsSBIvScBnDTk1WrlGIZBorIDEYJj+rhdgnQ67VmWRe0zlplXl81vcyEt0rSoYDUAAAAASUVORK5CYII=",
    downloads: {
      chrome: "https://chrome.google.com/webstore/detail/mcohilncbfahbmgdjkbpemcciiolgcge",
      firefox: "https://addons.mozilla.org/en-US/firefox/addon/okexwallet",
      edge: "https://microsoftedge.microsoft.com/addons/detail/%E6%AC%A7%E6%98%93-web3-%E9%92%B1%E5%8C%85/pbpjkcldjiffchgbbndmhojiacbgflha",
      safari: "https://apps.apple.com/us/app/okx-wallet/id6463797825"
    }
  },
  {
    id: "metamask",
    name: "MetaMask",
    icon: "data:image/svg+xml;utf8;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMTIiIGhlaWdodD0iMTg5IiB2aWV3Qm94PSIwIDAgMjEyIDE4OSI+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj48cG9seWdvbiBmaWxsPSIjQ0RCREIyIiBwb2ludHM9IjYwLjc1IDE3My4yNSA4OC4zMTMgMTgwLjU2MyA4OC4zMTMgMTcxIDkwLjU2MyAxNjguNzUgMTA2LjMxMyAxNjguNzUgMTA2LjMxMyAxODAgMTA2LjMxMyAxODcuODc1IDg5LjQzOCAxODcuODc1IDY4LjYyNSAxNzguODc1Ii8+PHBvbHlnb24gZmlsbD0iI0NEQkRCMiIgcG9pbnRzPSIxMDUuNzUgMTczLjI1IDEzMi43NSAxODAuNTYzIDEzMi43NSAxNzEgMTM1IDE2OC43NSAxNTAuNzUgMTY4Ljc1IDE1MC43NSAxODAgMTUwLjc1IDE4Ny44NzUgMTMzLjg3NSAxODcuODc1IDExMy4wNjMgMTc4Ljg3NSIgdHJhbnNmb3JtPSJtYXRyaXgoLTEgMCAwIDEgMjU2LjUgMCkiLz48cG9seWdvbiBmaWxsPSIjMzkzOTM5IiBwb2ludHM9IjkwLjU2MyAxNTIuNDM4IDg4LjMxMyAxNzEgOTEuMTI1IDE2OC43NSAxMjAuMzc1IDE2OC43NSAxMjMuNzUgMTcxIDEyMS41IDE1Mi40MzggMTE3IDE0OS42MjUgOTQuNSAxNTAuMTg4Ii8+PHBvbHlnb24gZmlsbD0iI0Y4OUMzNSIgcG9pbnRzPSI3NS4zNzUgMjcgODguODc1IDU4LjUgOTUuMDYzIDE1MC4xODggMTE3IDE1MC4xODggMTIzLjc1IDU4LjUgMTM2LjEyNSAyNyIvPjxwb2x5Z29uIGZpbGw9IiNGODlEMzUiIHBvaW50cz0iMTYuMzEzIDk2LjE4OCAuNTYzIDE0MS43NSAzOS45MzggMTM5LjUgNjUuMjUgMTM5LjUgNjUuMjUgMTE5LjgxMyA2NC4xMjUgNzkuMzEzIDU4LjUgODMuODEzIi8+PHBvbHlnb24gZmlsbD0iI0Q4N0MzMCIgcG9pbnRzPSI0Ni4xMjUgMTAxLjI1IDkyLjI1IDEwMi4zNzUgODcuMTg4IDEyNiA2NS4yNSAxMjAuMzc1Ii8+PHBvbHlnb24gZmlsbD0iI0VBOEQzQSIgcG9pbnRzPSI0Ni4xMjUgMTAxLjgxMyA2NS4yNSAxMTkuODEzIDY1LjI1IDEzNy44MTMiLz48cG9seWdvbiBmaWxsPSIjRjg5RDM1IiBwb2ludHM9IjY1LjI1IDEyMC4zNzUgODcuNzUgMTI2IDk1LjA2MyAxNTAuMTg4IDkwIDE1MyA2NS4yNSAxMzguMzc1Ii8+PHBvbHlnb24gZmlsbD0iI0VCOEYzNSIgcG9pbnRzPSI2NS4yNSAxMzguMzc1IDYwLjc1IDE3My4yNSA5MC41NjMgMTUyLjQzOCIvPjxwb2x5Z29uIGZpbGw9IiNFQThFM0EiIHBvaW50cz0iOTIuMjUgMTAyLjM3NSA5NS4wNjMgMTUwLjE4OCA4Ni42MjUgMTI1LjcxOSIvPjxwb2x5Z29uIGZpbGw9IiNEODdDMzAiIHBvaW50cz0iMzkuMzc1IDEzOC45MzggNjUuMjUgMTM4LjM3NSA2MC43NSAxNzMuMjUiLz48cG9seWdvbiBmaWxsPSIjRUI4RjM1IiBwb2ludHM9IjEyLjkzOCAxODguNDM4IDYwLjc1IDE3My4yNSAzOS4zNzUgMTM4LjkzOCAuNTYzIDE0MS43NSIvPjxwb2x5Z29uIGZpbGw9IiNFODgyMUUiIHBvaW50cz0iODguODc1IDU4LjUgNjQuNjg4IDc4Ljc1IDQ2LjEyNSAxMDEuMjUgOTIuMjUgMTAyLjkzOCIvPjxwb2x5Z29uIGZpbGw9IiNERkNFQzMiIHBvaW50cz0iNjAuNzUgMTczLjI1IDkwLjU2MyAxNTIuNDM4IDg4LjMxMyAxNzAuNDM4IDg4LjMxMyAxODAuNTYzIDY4LjA2MyAxNzYuNjI1Ii8+PHBvbHlnb24gZmlsbD0iI0RGQ0VDMyIgcG9pbnRzPSIxMjEuNSAxNzMuMjUgMTUwLjc1IDE1Mi40MzggMTQ4LjUgMTcwLjQzOCAxNDguNSAxODAuNTYzIDEyOC4yNSAxNzYuNjI1IiB0cmFuc2Zvcm09Im1hdHJpeCgtMSAwIDAgMSAyNzIuMjUgMCkiLz48cG9seWdvbiBmaWxsPSIjMzkzOTM5IiBwb2ludHM9IjcwLjMxMyAxMTIuNSA2NC4xMjUgMTI1LjQzOCA4Ni4wNjMgMTE5LjgxMyIgdHJhbnNmb3JtPSJtYXRyaXgoLTEgMCAwIDEgMTUwLjE4OCAwKSIvPjxwb2x5Z29uIGZpbGw9IiNFODhGMzUiIHBvaW50cz0iMTIuMzc1IC41NjMgODguODc1IDU4LjUgNzUuOTM4IDI3Ii8+PHBhdGggZmlsbD0iIzhFNUEzMCIgZD0iTTEyLjM3NTAwMDIsMC41NjI1MDAwMDggTDIuMjUwMDAwMDMsMzEuNTAwMDAwNSBMNy44NzUwMDAxMiw2NS4yNTAwMDEgTDMuOTM3NTAwMDYsNjcuNTAwMDAxIEw5LjU2MjUwMDE0LDcyLjU2MjUgTDUuMDYyNTAwMDgsNzYuNTAwMDAxMSBMMTEuMjUsODIuMTI1MDAxMiBMNy4zMTI1MDAxMSw4NS41MDAwMDEzIEwxNi4zMTI1MDAyLDk2Ljc1MDAwMTQgTDU4LjUwMDAwMDksODMuODEyNTAxMiBDNzkuMTI1MDAxMiw2Ny4zMTI1MDA0IDg5LjI1MDAwMTMsNTguODc1MDAwMyA4OC44NzUwMDEzLDU4LjUwMDAwMDkgQzg4LjUwMDAwMTMsNTguMTI1MDAwOSA2My4wMDAwMDA5LDM4LjgxMjUwMDYgMTIuMzc1MDAwMiwwLjU2MjUwMDAwOCBaIi8+PGcgdHJhbnNmb3JtPSJtYXRyaXgoLTEgMCAwIDEgMjExLjUgMCkiPjxwb2x5Z29uIGZpbGw9IiNGODlEMzUiIHBvaW50cz0iMTYuMzEzIDk2LjE4OCAuNTYzIDE0MS43NSAzOS45MzggMTM5LjUgNjUuMjUgMTM5LjUgNjUuMjUgMTE5LjgxMyA2NC4xMjUgNzkuMzEzIDU4LjUgODMuODEzIi8+PHBvbHlnb24gZmlsbD0iI0Q4N0MzMCIgcG9pbnRzPSI0Ni4xMjUgMTAxLjI1IDkyLjI1IDEwMi4zNzUgODcuMTg4IDEyNiA2NS4yNSAxMjAuMzc1Ii8+PHBvbHlnb24gZmlsbD0iI0VBOEQzQSIgcG9pbnRzPSI0Ni4xMjUgMTAxLjgxMyA2NS4yNSAxMTkuODEzIDY1LjI1IDEzNy44MTMiLz48cG9seWdvbiBmaWxsPSIjRjg5RDM1IiBwb2ludHM9IjY1LjI1IDEyMC4zNzUgODcuNzUgMTI2IDk1LjA2MyAxNTAuMTg4IDkwIDE1MyA2NS4yNSAxMzguMzc1Ii8+PHBvbHlnb24gZmlsbD0iI0VCOEYzNSIgcG9pbnRzPSI2NS4yNSAxMzguMzc1IDYwLjc1IDE3My4yNSA5MCAxNTMiLz48cG9seWdvbiBmaWxsPSIjRUE4RTNBIiBwb2ludHM9IjkyLjI1IDEwMi4zNzUgOTUuMDYzIDE1MC4xODggODYuNjI1IDEyNS43MTkiLz48cG9seWdvbiBmaWxsPSIjRDg3QzMwIiBwb2ludHM9IjM5LjM3NSAxMzguOTM4IDY1LjI1IDEzOC4zNzUgNjAuNzUgMTczLjI1Ii8+PHBvbHlnb24gZmlsbD0iI0VCOEYzNSIgcG9pbnRzPSIxMi45MzggMTg4LjQzOCA2MC43NSAxNzMuMjUgMzkuMzc1IDEzOC45MzggLjU2MyAxNDEuNzUiLz48cG9seWdvbiBmaWxsPSIjRTg4MjFFIiBwb2ludHM9Ijg4Ljg3NSA1OC41IDY0LjY4OCA3OC43NSA0Ni4xMjUgMTAxLjI1IDkyLjI1IDEwMi45MzgiLz48cG9seWdvbiBmaWxsPSIjMzkzOTM5IiBwb2ludHM9IjcwLjMxMyAxMTIuNSA2NC4xMjUgMTI1LjQzOCA4Ni4wNjMgMTE5LjgxMyIgdHJhbnNmb3JtPSJtYXRyaXgoLTEgMCAwIDEgMTUwLjE4OCAwKSIvPjxwb2x5Z29uIGZpbGw9IiNFODhGMzUiIHBvaW50cz0iMTIuMzc1IC41NjMgODguODc1IDU4LjUgNzUuOTM4IDI3Ii8+PHBhdGggZmlsbD0iIzhFNUEzMCIgZD0iTTEyLjM3NTAwMDIsMC41NjI1MDAwMDggTDIuMjUwMDAwMDMsMzEuNTAwMDAwNSBMNy44NzUwMDAxMiw2NS4yNTAwMDEgTDMuOTM3NTAwMDYsNjcuNTAwMDAxIEw5LjU2MjUwMDE0LDcyLjU2MjUgTDUuMDYyNTAwMDgsNzYuNTAwMDAxMSBMMTEuMjUsODIuMTI1MDAxMiBMNy4zMTI1MDAxMSw4NS41MDAwMDEzIEwxNi4zMTI1MDAyLDk2Ljc1MDAwMTQgTDU4LjUwMDAwMDksODMuODEyNTAxMiBDNzkuMTI1MDAxMiw2Ny4zMTI1MDA0IDg5LjI1MDAwMTMsNTguODc1MDAwMyA4OC44NzUwMDEzLDU4LjUwMDAwMDkgQzg4LjUwMDAwMTMsNTguMTI1MDAwOSA2My4wMDAwMDA5LDM4LjgxMjUwMDYgMTIuMzc1MDAwMiwwLjU2MjUwMDAwOCBaIi8+PC9nPjwvZz48L3N2Zz4=",
    downloads: {
      chrome: "https://chrome.google.com/webstore/detail/metamask/nkbihfbeogaeaoehlefnkodbefgpgknn",
      firefox: "https://addons.mozilla.org/en-US/firefox/addon/ether-metamask/",
      edge: "https://microsoftedge.microsoft.com/addons/detail/metamask/ejbalbakoplchlghecdalmeeeajnimhm?hl=en-US"
    }
  }
];
var T, j, x, H, Q, C, G;
class LocalStorageWrapper {
  constructor(e) {
    L(this, H);
    L(this, C);
    L(this, T, !1);
    L(this, j, void 0);
    L(this, x, void 0);
    F(this, "value");
    $(this, x, e), P(this, C, G).call(this);
  }
  set(e) {
    return !N(this, T) && !P(this, C, G).call(this) ? !1 : (this.delete(), this.value = e, e && ($(this, j, `${N(this, x)}-${generateUID()}`), localStorage.setItem(N(this, j), e)), !0);
  }
  get() {
    return P(this, H, Q).call(this), this.value;
  }
  delete() {
    return !N(this, T) && !P(this, C, G).call(this) ? !1 : (this.value = null, N(this, j) && localStorage.removeItem(N(this, j)), !0);
  }
}
T = new WeakMap(), j = new WeakMap(), x = new WeakMap(), H = new WeakSet(), Q = function() {
  this.value && this.set(this.value);
}, C = new WeakSet(), G = function() {
  try {
    !N(this, T) && typeof window < "u" && ($(this, j, Object.keys(localStorage).find(
      (e) => e.startsWith(N(this, x))
    )), $(this, T, !0), N(this, j) && this.set(localStorage.getItem(N(this, j))));
  } catch (e) {
    console.warn(e);
  }
  return N(this, T);
};
function filterBy(t, e) {
  var n, r;
  if ((n = e == null ? void 0 : e.include) != null && n.length) {
    const o = new Set(e.include);
    return t.filter((s) => o.has(s.id));
  }
  if ((r = e == null ? void 0 : e.exclude) != null && r.length) {
    const o = new Set(e.exclude);
    return t.filter((s) => !o.has(s.id));
  }
  return t;
}
const filterByPreAuthorized = async (t) => {
  const e = await Promise.all(
    t.map((n) => n.isPreauthorized().catch(() => !1))
  );
  return t.filter((n, r) => e[r]);
}, isWalletObj = (t) => {
  try {
    return t && [
      "request",
      "isConnected",
      "provider",
      "enable",
      "isPreauthorized",
      "on",
      "off",
      "version",
      "id",
      "name",
      "icon"
    ].every((e) => e in t);
  } catch {
  }
  return !1;
};
function getBuilderId() {
  return typeof FEDERATION_BUILD_IDENTIFIER < "u" ? FEDERATION_BUILD_IDENTIFIER : "";
}
function isDebugMode$1() {
  return Boolean("");
}
function isBrowserEnv$1() {
  return typeof window < "u";
}
const LOG_CATEGORY$1 = "[ Federation Runtime ]";
function assert(t, e) {
  t || error(e);
}
function error(t) {
  throw t instanceof Error ? (t.message = `${LOG_CATEGORY$1}: ${t.message}`, t) : new Error(`${LOG_CATEGORY$1}: ${t}`);
}
function warn$1(t) {
  t instanceof Error ? (t.message = `${LOG_CATEGORY$1}: ${t.message}`, console.warn(t)) : console.warn(`${LOG_CATEGORY$1}: ${t}`);
}
function addUniqueItem(t, e) {
  return t.findIndex((n) => n === e) === -1 && t.push(e), t;
}
function getFMId(t) {
  return "version" in t && t.version ? `${t.name}:${t.version}` : "entry" in t && t.entry ? `${t.name}:${t.entry}` : `${t.name}`;
}
function isRemoteInfoWithEntry(t) {
  return typeof t.entry < "u";
}
function isPureRemoteEntry(t) {
  return !t.entry.includes(".json") && t.entry.includes(".js");
}
function safeToString$1(t) {
  try {
    return JSON.stringify(t, null, 2);
  } catch {
    return "";
  }
}
function isObject(t) {
  return t && typeof t == "object";
}
const objectToString = Object.prototype.toString;
function isPlainObject(t) {
  return objectToString.call(t) === "[object Object]";
}
function _extends$1$1() {
  return _extends$1$1 = Object.assign || function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]);
    }
    return t;
  }, _extends$1$1.apply(this, arguments);
}
function _object_without_properties_loose$1(t, e) {
  if (t == null)
    return {};
  var n = {}, r = Object.keys(t), o, s;
  for (s = 0; s < r.length; s++)
    o = r[s], !(e.indexOf(o) >= 0) && (n[o] = t[o]);
  return n;
}
const nativeGlobal = (() => {
  try {
    return new Function("return this")();
  } catch {
    return globalThis;
  }
})(), Global = nativeGlobal;
function definePropertyGlobalVal(t, e, n) {
  Object.defineProperty(t, e, {
    value: n,
    configurable: !1,
    writable: !0
  });
}
function includeOwnProperty(t, e) {
  return Object.hasOwnProperty.call(t, e);
}
includeOwnProperty(globalThis, "__GLOBAL_LOADING_REMOTE_ENTRY__") || definePropertyGlobalVal(globalThis, "__GLOBAL_LOADING_REMOTE_ENTRY__", {});
const globalLoading = globalThis.__GLOBAL_LOADING_REMOTE_ENTRY__;
function setGlobalDefaultVal(t) {
  var e, n, r, o, s, i;
  includeOwnProperty(t, "__VMOK__") && !includeOwnProperty(t, "__FEDERATION__") && definePropertyGlobalVal(t, "__FEDERATION__", t.__VMOK__), includeOwnProperty(t, "__FEDERATION__") || (definePropertyGlobalVal(t, "__FEDERATION__", {
    __GLOBAL_PLUGIN__: [],
    __INSTANCES__: [],
    moduleInfo: {},
    __SHARE__: {},
    __MANIFEST_LOADING__: {},
    __PRELOADED_MAP__: /* @__PURE__ */ new Map()
  }), definePropertyGlobalVal(t, "__VMOK__", t.__FEDERATION__));
  var a;
  (a = (e = t.__FEDERATION__).__GLOBAL_PLUGIN__) != null || (e.__GLOBAL_PLUGIN__ = []);
  var l;
  (l = (n = t.__FEDERATION__).__INSTANCES__) != null || (n.__INSTANCES__ = []);
  var c;
  (c = (r = t.__FEDERATION__).moduleInfo) != null || (r.moduleInfo = {});
  var u;
  (u = (o = t.__FEDERATION__).__SHARE__) != null || (o.__SHARE__ = {});
  var d;
  (d = (s = t.__FEDERATION__).__MANIFEST_LOADING__) != null || (s.__MANIFEST_LOADING__ = {});
  var h;
  (h = (i = t.__FEDERATION__).__PRELOADED_MAP__) != null || (i.__PRELOADED_MAP__ = /* @__PURE__ */ new Map());
}
setGlobalDefaultVal(globalThis);
setGlobalDefaultVal(nativeGlobal);
function getGlobalFederationInstance(t, e) {
  const n = getBuilderId();
  return globalThis.__FEDERATION__.__INSTANCES__.find((r) => !!(n && r.options.id === getBuilderId() || r.options.name === t && !r.options.version && !e || r.options.name === t && e && r.options.version === e));
}
function setGlobalFederationInstance(t) {
  globalThis.__FEDERATION__.__INSTANCES__.push(t);
}
function getGlobalFederationConstructor() {
  return globalThis.__FEDERATION__.__DEBUG_CONSTRUCTOR__;
}
function setGlobalFederationConstructor(t, e = isDebugMode$1()) {
  e && (globalThis.__FEDERATION__.__DEBUG_CONSTRUCTOR__ = t, globalThis.__FEDERATION__.__DEBUG_CONSTRUCTOR_VERSION__ = "0.1.2");
}
function getInfoWithoutType(t, e) {
  if (typeof e == "string") {
    if (t[e])
      return {
        value: t[e],
        key: e
      };
    {
      const r = Object.keys(t);
      for (const o of r) {
        const [s, i] = o.split(":"), a = `${s}:${e}`, l = t[a];
        if (l)
          return {
            value: l,
            key: a
          };
      }
      return {
        value: void 0,
        key: e
      };
    }
  } else
    throw new Error("key must be string");
}
const getGlobalSnapshot = () => nativeGlobal.__FEDERATION__.moduleInfo, getTargetSnapshotInfoByModuleInfo = (t, e) => {
  const n = getFMId(t), r = getInfoWithoutType(e, n).value;
  if (r && !r.version && "version" in t && t.version && (r.version = t.version), r)
    return r;
  if ("version" in t && t.version) {
    const { version: o } = t, s = _object_without_properties_loose$1(t, [
      "version"
    ]), i = getFMId(s), a = getInfoWithoutType(nativeGlobal.__FEDERATION__.moduleInfo, i).value;
    if ((a == null ? void 0 : a.version) === o)
      return a;
  }
}, getGlobalSnapshotInfoByModuleInfo = (t) => getTargetSnapshotInfoByModuleInfo(t, nativeGlobal.__FEDERATION__.moduleInfo), setGlobalSnapshotInfoByModuleInfo = (t, e) => {
  const n = getFMId(t);
  return nativeGlobal.__FEDERATION__.moduleInfo[n] = e, nativeGlobal.__FEDERATION__.moduleInfo;
}, addGlobalSnapshot = (t) => (nativeGlobal.__FEDERATION__.moduleInfo = _extends$1$1({}, nativeGlobal.__FEDERATION__.moduleInfo, t), () => {
  const e = Object.keys(t);
  for (const n of e)
    delete nativeGlobal.__FEDERATION__.moduleInfo[n];
}), getRemoteEntryExports = (t, e) => {
  const n = e || `__FEDERATION_${t}:custom__`, r = globalThis[n];
  return {
    remoteEntryKey: n,
    entryExports: r
  };
}, getGlobalHostPlugins = () => nativeGlobal.__FEDERATION__.__GLOBAL_PLUGIN__, getPreloaded = (t) => globalThis.__FEDERATION__.__PRELOADED_MAP__.get(t), setPreloaded = (t) => globalThis.__FEDERATION__.__PRELOADED_MAP__.set(t, !0), DEFAULT_SCOPE = "default", DEFAULT_REMOTE_TYPE = "global", buildIdentifier = "[0-9A-Za-z-]+", build = `(?:\\+(${buildIdentifier}(?:\\.${buildIdentifier})*))`, numericIdentifier = "0|[1-9]\\d*", numericIdentifierLoose = "[0-9]+", nonNumericIdentifier = "\\d*[a-zA-Z-][a-zA-Z0-9-]*", preReleaseIdentifierLoose = `(?:${numericIdentifierLoose}|${nonNumericIdentifier})`, preReleaseLoose = `(?:-?(${preReleaseIdentifierLoose}(?:\\.${preReleaseIdentifierLoose})*))`, preReleaseIdentifier = `(?:${numericIdentifier}|${nonNumericIdentifier})`, preRelease = `(?:-(${preReleaseIdentifier}(?:\\.${preReleaseIdentifier})*))`, xRangeIdentifier = `${numericIdentifier}|x|X|\\*`, xRangePlain = `[v=\\s]*(${xRangeIdentifier})(?:\\.(${xRangeIdentifier})(?:\\.(${xRangeIdentifier})(?:${preRelease})?${build}?)?)?`, hyphenRange = `^\\s*(${xRangePlain})\\s+-\\s+(${xRangePlain})\\s*$`, mainVersionLoose = `(${numericIdentifierLoose})\\.(${numericIdentifierLoose})\\.(${numericIdentifierLoose})`, loosePlain = `[v=\\s]*${mainVersionLoose}${preReleaseLoose}?${build}?`, gtlt = "((?:<|>)?=?)", comparatorTrim = `(\\s*)${gtlt}\\s*(${loosePlain}|${xRangePlain})`, loneTilde = "(?:~>?)", tildeTrim = `(\\s*)${loneTilde}\\s+`, loneCaret = "(?:\\^)", caretTrim = `(\\s*)${loneCaret}\\s+`, star = "(<|>)?=?\\s*\\*", caret = `^${loneCaret}${xRangePlain}$`, mainVersion = `(${numericIdentifier})\\.(${numericIdentifier})\\.(${numericIdentifier})`, fullPlain = `v?${mainVersion}${preRelease}?${build}?`, tilde = `^${loneTilde}${xRangePlain}$`, xRange = `^${gtlt}\\s*${xRangePlain}$`, comparator = `^${gtlt}\\s*(${fullPlain})$|^$`, gte0 = "^\\s*>=\\s*0.0.0\\s*$";
function parseRegex(t) {
  return new RegExp(t);
}
function isXVersion(t) {
  return !t || t.toLowerCase() === "x" || t === "*";
}
function pipe(...t) {
  return (e) => t.reduce((n, r) => r(n), e);
}
function extractComparator(t) {
  return t.match(parseRegex(comparator));
}
function combineVersion(t, e, n, r) {
  const o = `${t}.${e}.${n}`;
  return r ? `${o}-${r}` : o;
}
function parseHyphen(t) {
  return t.replace(parseRegex(hyphenRange), (e, n, r, o, s, i, a, l, c, u, d, h) => (isXVersion(r) ? n = "" : isXVersion(o) ? n = `>=${r}.0.0` : isXVersion(s) ? n = `>=${r}.${o}.0` : n = `>=${n}`, isXVersion(c) ? l = "" : isXVersion(u) ? l = `<${Number(c) + 1}.0.0-0` : isXVersion(d) ? l = `<${c}.${Number(u) + 1}.0-0` : h ? l = `<=${c}.${u}.${d}-${h}` : l = `<=${l}`, `${n} ${l}`.trim()));
}
function parseComparatorTrim(t) {
  return t.replace(parseRegex(comparatorTrim), "$1$2$3");
}
function parseTildeTrim(t) {
  return t.replace(parseRegex(tildeTrim), "$1~");
}
function parseCaretTrim(t) {
  return t.replace(parseRegex(caretTrim), "$1^");
}
function parseCarets(t) {
  return t.trim().split(/\s+/).map((e) => e.replace(parseRegex(caret), (n, r, o, s, i) => isXVersion(r) ? "" : isXVersion(o) ? `>=${r}.0.0 <${Number(r) + 1}.0.0-0` : isXVersion(s) ? r === "0" ? `>=${r}.${o}.0 <${r}.${Number(o) + 1}.0-0` : `>=${r}.${o}.0 <${Number(r) + 1}.0.0-0` : i ? r === "0" ? o === "0" ? `>=${r}.${o}.${s}-${i} <${r}.${o}.${Number(s) + 1}-0` : `>=${r}.${o}.${s}-${i} <${r}.${Number(o) + 1}.0-0` : `>=${r}.${o}.${s}-${i} <${Number(r) + 1}.0.0-0` : r === "0" ? o === "0" ? `>=${r}.${o}.${s} <${r}.${o}.${Number(s) + 1}-0` : `>=${r}.${o}.${s} <${r}.${Number(o) + 1}.0-0` : `>=${r}.${o}.${s} <${Number(r) + 1}.0.0-0`)).join(" ");
}
function parseTildes(t) {
  return t.trim().split(/\s+/).map((e) => e.replace(parseRegex(tilde), (n, r, o, s, i) => isXVersion(r) ? "" : isXVersion(o) ? `>=${r}.0.0 <${Number(r) + 1}.0.0-0` : isXVersion(s) ? `>=${r}.${o}.0 <${r}.${Number(o) + 1}.0-0` : i ? `>=${r}.${o}.${s}-${i} <${r}.${Number(o) + 1}.0-0` : `>=${r}.${o}.${s} <${r}.${Number(o) + 1}.0-0`)).join(" ");
}
function parseXRanges(t) {
  return t.split(/\s+/).map((e) => e.trim().replace(parseRegex(xRange), (n, r, o, s, i, a) => {
    const l = isXVersion(o), c = l || isXVersion(s), u = c || isXVersion(i);
    return r === "=" && u && (r = ""), a = "", l ? r === ">" || r === "<" ? "<0.0.0-0" : "*" : r && u ? (c && (s = 0), i = 0, r === ">" ? (r = ">=", c ? (o = Number(o) + 1, s = 0, i = 0) : (s = Number(s) + 1, i = 0)) : r === "<=" && (r = "<", c ? o = Number(o) + 1 : s = Number(s) + 1), r === "<" && (a = "-0"), `${r + o}.${s}.${i}${a}`) : c ? `>=${o}.0.0${a} <${Number(o) + 1}.0.0-0` : u ? `>=${o}.${s}.0${a} <${o}.${Number(s) + 1}.0-0` : n;
  })).join(" ");
}
function parseStar(t) {
  return t.trim().replace(parseRegex(star), "");
}
function parseGTE0(t) {
  return t.trim().replace(parseRegex(gte0), "");
}
function compareAtom(t, e) {
  return t = Number(t) || t, e = Number(e) || e, t > e ? 1 : t === e ? 0 : -1;
}
function comparePreRelease(t, e) {
  const { preRelease: n } = t, { preRelease: r } = e;
  if (n === void 0 && Boolean(r))
    return 1;
  if (Boolean(n) && r === void 0)
    return -1;
  if (n === void 0 && r === void 0)
    return 0;
  for (let o = 0, s = n.length; o <= s; o++) {
    const i = n[o], a = r[o];
    if (i !== a)
      return i === void 0 && a === void 0 ? 0 : i ? a ? compareAtom(i, a) : -1 : 1;
  }
  return 0;
}
function compareVersion(t, e) {
  return compareAtom(t.major, e.major) || compareAtom(t.minor, e.minor) || compareAtom(t.patch, e.patch) || comparePreRelease(t, e);
}
function eq(t, e) {
  return t.version === e.version;
}
function compare(t, e) {
  switch (t.operator) {
    case "":
    case "=":
      return eq(t, e);
    case ">":
      return compareVersion(t, e) < 0;
    case ">=":
      return eq(t, e) || compareVersion(t, e) < 0;
    case "<":
      return compareVersion(t, e) > 0;
    case "<=":
      return eq(t, e) || compareVersion(t, e) > 0;
    case void 0:
      return !0;
    default:
      return !1;
  }
}
function parseComparatorString(t) {
  return pipe(
    parseCarets,
    parseTildes,
    parseXRanges,
    parseStar
  )(t);
}
function parseRange(t) {
  return pipe(
    parseHyphen,
    parseComparatorTrim,
    parseTildeTrim,
    parseCaretTrim
  )(t.trim()).split(/\s+/).join(" ");
}
function satisfy(t, e) {
  if (!t)
    return !1;
  const o = parseRange(e).split(" ").map((h) => parseComparatorString(h)).join(" ").split(/\s+/).map((h) => parseGTE0(h)), s = extractComparator(t);
  if (!s)
    return !1;
  const [, i, , a, l, c, u] = s, d = {
    operator: i,
    version: combineVersion(a, l, c, u),
    major: a,
    minor: l,
    patch: c,
    preRelease: u == null ? void 0 : u.split(".")
  };
  for (const h of o) {
    const M = extractComparator(h);
    if (!M)
      return !1;
    const [, I, , m, g, p, E] = M, y = {
      operator: I,
      version: combineVersion(m, g, p, E),
      major: m,
      minor: g,
      patch: p,
      preRelease: E == null ? void 0 : E.split(".")
    };
    if (!compare(y, d))
      return !1;
  }
  return !0;
}
function _extends$6() {
  return _extends$6 = Object.assign || function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]);
    }
    return t;
  }, _extends$6.apply(this, arguments);
}
function formatShare(t, e) {
  let n;
  return "get" in t ? n = t.get : n = () => Promise.resolve(t.lib), _extends$6({
    deps: [],
    useIn: [],
    from: e,
    loading: null
  }, t, {
    shareConfig: _extends$6({
      requiredVersion: `^${t.version}`,
      singleton: !1,
      eager: !1,
      strictVersion: !1
    }, t.shareConfig),
    get: n,
    loaded: "lib" in t ? !0 : void 0,
    scope: Array.isArray(t.scope) ? t.scope : [
      "default"
    ],
    strategy: t.strategy || "version-first"
  });
}
function formatShareConfigs(t, e) {
  return t ? Object.keys(t).reduce((n, r) => (n[r] = formatShare(t[r], e), n), {}) : {};
}
function versionLt(t, e) {
  const n = (r) => {
    if (!Number.isNaN(Number(r))) {
      const s = r.split(".");
      let i = r;
      for (let a = 0; a < 3 - s.length; a++)
        i += ".0";
      return i;
    }
    return r;
  };
  return !!satisfy(n(t), `<=${n(e)}`);
}
const findVersion = (t, e, n, r) => {
  const o = t[e][n], s = r || function(i, a) {
    return versionLt(i, a);
  };
  return Object.keys(o).reduce((i, a) => !i || s(i, a) || i === "0" ? a : i, 0);
}, isLoaded = (t) => Boolean(t.loaded) || typeof t.lib == "function";
function findSingletonVersionOrderByVersion(t, e, n) {
  const r = t[e][n];
  return findVersion(t, e, n, function(s, i) {
    return !isLoaded(r[s]) && versionLt(s, i);
  });
}
function findSingletonVersionOrderByLoaded(t, e, n) {
  const r = t[e][n];
  return findVersion(t, e, n, function(s, i) {
    return isLoaded(r[i]) ? isLoaded(r[s]) ? Boolean(versionLt(s, i)) : !0 : isLoaded(r[s]) ? !1 : versionLt(s, i);
  });
}
function getFindShareFunction(t) {
  return t === "loaded-first" ? findSingletonVersionOrderByLoaded : findSingletonVersionOrderByVersion;
}
function getRegisteredShare(t, e, n, r) {
  if (!t)
    return;
  const { shareConfig: o, scope: s = DEFAULT_SCOPE, strategy: i } = n, a = Array.isArray(s) ? s : [
    s
  ];
  for (const l of a)
    if (o && t[l] && t[l][e]) {
      const { requiredVersion: c } = o, d = getFindShareFunction(i)(t, l, e), h = () => {
        if (o.singleton) {
          if (typeof c == "string" && !satisfy(d, c)) {
            const m = `Version ${d} from ${d && t[l][e][d].from} of shared singleton module ${e} does not satisfy the requirement of ${n.from} which needs ${c})`;
            o.strictVersion ? error(m) : warn$1(m);
          }
          return t[l][e][d];
        } else {
          if (c === !1 || c === "*" || satisfy(d, c))
            return t[l][e][d];
          for (const [m, g] of Object.entries(t[l][e]))
            if (satisfy(m, c))
              return g;
        }
      }, M = {
        shareScopeMap: t,
        scope: l,
        pkgName: e,
        version: d,
        GlobalFederation: Global.__FEDERATION__,
        resolver: h
      };
      return (r.emit(M) || M).resolver();
    }
}
function getGlobalShareScope() {
  return Global.__FEDERATION__.__SHARE__;
}
function _define_property$3(t, e, n) {
  return e in t ? Object.defineProperty(t, e, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : t[e] = n, t;
}
var MANIFEST_EXT = ".json", BROWSER_LOG_KEY = "FEDERATION_DEBUG", BROWSER_LOG_VALUE = "1", NameTransformSymbol = {
  AT: "@",
  HYPHEN: "-",
  SLASH: "/"
}, _obj, NameTransformMap = (_obj = {}, _define_property$3(_obj, NameTransformSymbol.AT, "scope_"), _define_property$3(_obj, NameTransformSymbol.HYPHEN, "_"), _define_property$3(_obj, NameTransformSymbol.SLASH, "__"), _obj), _obj1;
_obj1 = {}, _define_property$3(_obj1, NameTransformMap[NameTransformSymbol.AT], NameTransformSymbol.AT), _define_property$3(_obj1, NameTransformMap[NameTransformSymbol.HYPHEN], NameTransformSymbol.HYPHEN), _define_property$3(_obj1, NameTransformMap[NameTransformSymbol.SLASH], NameTransformSymbol.SLASH);
var SEPARATOR = ":";
function isBrowserEnv() {
  return typeof window < "u";
}
function isDebugMode() {
  return typeof process < "u" && process.env && process.env.FEDERATION_DEBUG ? Boolean(process.env.FEDERATION_DEBUG) : typeof FEDERATION_DEBUG < "u" && Boolean(FEDERATION_DEBUG);
}
function _array_like_to_array$2(t, e) {
  (e == null || e > t.length) && (e = t.length);
  for (var n = 0, r = new Array(e); n < e; n++)
    r[n] = t[n];
  return r;
}
function _array_without_holes(t) {
  if (Array.isArray(t))
    return _array_like_to_array$2(t);
}
function _class_call_check(t, e) {
  if (!(t instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(t, e) {
  for (var n = 0; n < e.length; n++) {
    var r = e[n];
    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);
  }
}
function _create_class(t, e, n) {
  return e && _defineProperties(t.prototype, e), n && _defineProperties(t, n), t;
}
function _define_property$2(t, e, n) {
  return e in t ? Object.defineProperty(t, e, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : t[e] = n, t;
}
function _iterable_to_array$1(t) {
  if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null)
    return Array.from(t);
}
function _non_iterable_spread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _to_consumable_array(t) {
  return _array_without_holes(t) || _iterable_to_array$1(t) || _unsupported_iterable_to_array$2(t) || _non_iterable_spread();
}
function _unsupported_iterable_to_array$2(t, e) {
  if (!!t) {
    if (typeof t == "string")
      return _array_like_to_array$2(t, e);
    var n = Object.prototype.toString.call(t).slice(8, -1);
    if (n === "Object" && t.constructor && (n = t.constructor.name), n === "Map" || n === "Set")
      return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _array_like_to_array$2(t, e);
  }
}
function safeToString(t) {
  try {
    return JSON.stringify(t, null, 2);
  } catch {
    return "";
  }
}
var DEBUG_LOG = "[ FEDERATION DEBUG ]";
function safeGetLocalStorageItem() {
  try {
    if (typeof window < "u" && window.localStorage)
      return localStorage.getItem(BROWSER_LOG_KEY) === BROWSER_LOG_VALUE;
  } catch {
    return typeof document < "u";
  }
  return !1;
}
var Logger = /* @__PURE__ */ function() {
  function t(e) {
    _class_call_check(this, t), _define_property$2(this, "enable", !1), _define_property$2(this, "identifier", void 0), this.identifier = e || DEBUG_LOG, isBrowserEnv() && safeGetLocalStorageItem() ? this.enable = !0 : isDebugMode() && (this.enable = !0);
  }
  return _create_class(t, [
    {
      key: "info",
      value: function(e, n) {
        if (this.enable) {
          var r = safeToString(n) || "";
          isBrowserEnv() ? console.info("%c ".concat(this.identifier, ": ").concat(e, " ").concat(r), "color:#3300CC") : console.info("\x1B[34m%s", "".concat(this.identifier, ": ").concat(e, " ").concat(r ? `
`.concat(r) : ""));
        }
      }
    },
    {
      key: "logOriginalInfo",
      value: function() {
        for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
          r[o] = arguments[o];
        if (this.enable)
          if (isBrowserEnv()) {
            var s;
            console.info("%c ".concat(this.identifier, ": OriginalInfo"), "color:#3300CC"), (s = console).log.apply(s, _to_consumable_array(r));
          } else {
            var i;
            console.info("%c ".concat(this.identifier, ": OriginalInfo"), "color:#3300CC"), (i = console).log.apply(i, _to_consumable_array(r));
          }
      }
    }
  ]), t;
}(), LOG_CATEGORY = "[ Federation Runtime ]";
new Logger();
var composeKeyWithSeparator = function() {
  for (var e = arguments.length, n = new Array(e), r = 0; r < e; r++)
    n[r] = arguments[r];
  return n.length ? n.reduce(function(o, s) {
    return s ? o ? "".concat(o).concat(SEPARATOR).concat(s) : s : o;
  }, "") : "";
}, getResourceUrl = function(t, e) {
  if ("getPublicPath" in t) {
    var n = new Function(t.getPublicPath)();
    return "".concat(n).concat(e);
  } else
    return "publicPath" in t ? "".concat(t.publicPath).concat(e) : (console.warn("Can not get resource url, if in debug mode, please ignore", t, e), "");
}, warn = function(t) {
  console.warn("".concat(LOG_CATEGORY, ": ").concat(t));
};
function _define_property$1(t, e, n) {
  return e in t ? Object.defineProperty(t, e, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : t[e] = n, t;
}
function _object_spread$1(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {}, r = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (r = r.concat(Object.getOwnPropertySymbols(n).filter(function(o) {
      return Object.getOwnPropertyDescriptor(n, o).enumerable;
    }))), r.forEach(function(o) {
      _define_property$1(t, o, n[o]);
    });
  }
  return t;
}
function ownKeys(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(t);
    e && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(t, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function _object_spread_props(t, e) {
  return e = e != null ? e : {}, Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(e)) : ownKeys(Object(e)).forEach(function(n) {
    Object.defineProperty(t, n, Object.getOwnPropertyDescriptor(e, n));
  }), t;
}
var simpleJoinRemoteEntry = function(t, e) {
  if (!t)
    return e;
  var n = function(o) {
    if (o === ".")
      return "";
    if (o.startsWith("./"))
      return o.replace("./", "");
    if (o.startsWith("/")) {
      var s = o.slice(1);
      return s.endsWith("/") ? s.slice(0, -1) : s;
    }
    return o;
  }, r = n(t);
  return r ? r.endsWith("/") ? "".concat(r).concat(e) : "".concat(r, "/").concat(e) : e;
};
function generateSnapshotFromManifest(t) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n, r, o = e.remotes, s = o === void 0 ? {} : o, i = e.overrides, a = i === void 0 ? {} : i, l = e.version, c, u = function() {
    return "publicPath" in t.metaData ? t.metaData.publicPath : t.metaData.getPublicPath;
  }, d = Object.keys(a), h = {};
  if (!Object.keys(s).length) {
    var M;
    h = ((M = t.remotes) === null || M === void 0 ? void 0 : M.reduce(function(b, k) {
      var U, W = k.federationContainerName;
      return d.includes(W) ? U = a[W] : "version" in k ? U = k.version : U = k.entry, b[W] = {
        matchedVersion: U
      }, b;
    }, {})) || {};
  }
  Object.keys(s).forEach(function(b) {
    return h[b] = {
      matchedVersion: d.includes(b) ? a[b] : s[b]
    };
  });
  var I = t.metaData, m = I.remoteEntry, g = m.path, p = m.name, E = m.type, y = I.types, S = I.buildInfo.buildVersion, z = I.globalName, v = t.exposes, w = {
    version: l || "",
    buildVersion: S,
    globalName: z,
    remoteEntry: simpleJoinRemoteEntry(g, p),
    remoteEntryType: E,
    remoteTypes: simpleJoinRemoteEntry(y.path, y.name),
    remoteTypesZip: y.zip || "",
    remoteTypesAPI: y.api || "",
    remotesInfo: h,
    shared: t == null ? void 0 : t.shared.map(function(b) {
      return {
        assets: b.assets,
        sharedName: b.name
      };
    }),
    modules: v == null ? void 0 : v.map(function(b) {
      return {
        moduleName: b.name,
        modulePath: b.path,
        assets: b.assets
      };
    })
  };
  if (!((n = t.metaData) === null || n === void 0) && n.prefetchInterface) {
    var O = t.metaData.prefetchInterface;
    w = _object_spread_props(_object_spread$1({}, w), {
      prefetchInterface: O
    });
  }
  if (!((r = t.metaData) === null || r === void 0) && r.prefetchEntry) {
    var A = t.metaData.prefetchEntry, _ = A.path, D = A.name, R = A.type;
    w = _object_spread_props(_object_spread$1({}, w), {
      prefetchEntry: simpleJoinRemoteEntry(_, D),
      prefetchEntryType: R
    });
  }
  return "publicPath" in t.metaData ? c = _object_spread_props(_object_spread$1({}, w), {
    publicPath: u()
  }) : c = _object_spread_props(_object_spread$1({}, w), {
    getPublicPath: u()
  }), c;
}
function isManifestProvider(t) {
  return !!("remoteEntry" in t && t.remoteEntry.includes(MANIFEST_EXT));
}
function asyncGeneratorStep$1(t, e, n, r, o, s, i) {
  try {
    var a = t[s](i), l = a.value;
  } catch (c) {
    n(c);
    return;
  }
  a.done ? e(l) : Promise.resolve(l).then(r, o);
}
function _async_to_generator$1(t) {
  return function() {
    var e = this, n = arguments;
    return new Promise(function(r, o) {
      var s = t.apply(e, n);
      function i(l) {
        asyncGeneratorStep$1(s, r, o, i, a, "next", l);
      }
      function a(l) {
        asyncGeneratorStep$1(s, r, o, i, a, "throw", l);
      }
      i(void 0);
    });
  };
}
function _instanceof(t, e) {
  return e != null && typeof Symbol < "u" && e[Symbol.hasInstance] ? !!e[Symbol.hasInstance](t) : t instanceof e;
}
function _ts_generator$1(t, e) {
  var n, r, o, s, i = {
    label: 0,
    sent: function() {
      if (o[0] & 1)
        throw o[1];
      return o[1];
    },
    trys: [],
    ops: []
  };
  return s = {
    next: a(0),
    throw: a(1),
    return: a(2)
  }, typeof Symbol == "function" && (s[Symbol.iterator] = function() {
    return this;
  }), s;
  function a(c) {
    return function(u) {
      return l([
        c,
        u
      ]);
    };
  }
  function l(c) {
    if (n)
      throw new TypeError("Generator is already executing.");
    for (; i; )
      try {
        if (n = 1, r && (o = c[0] & 2 ? r.return : c[0] ? r.throw || ((o = r.return) && o.call(r), 0) : r.next) && !(o = o.call(r, c[1])).done)
          return o;
        switch (r = 0, o && (c = [
          c[0] & 2,
          o.value
        ]), c[0]) {
          case 0:
          case 1:
            o = c;
            break;
          case 4:
            return i.label++, {
              value: c[1],
              done: !1
            };
          case 5:
            i.label++, r = c[1], c = [
              0
            ];
            continue;
          case 7:
            c = i.ops.pop(), i.trys.pop();
            continue;
          default:
            if (o = i.trys, !(o = o.length > 0 && o[o.length - 1]) && (c[0] === 6 || c[0] === 2)) {
              i = 0;
              continue;
            }
            if (c[0] === 3 && (!o || c[1] > o[0] && c[1] < o[3])) {
              i.label = c[1];
              break;
            }
            if (c[0] === 6 && i.label < o[1]) {
              i.label = o[1], o = c;
              break;
            }
            if (o && i.label < o[2]) {
              i.label = o[2], i.ops.push(c);
              break;
            }
            o[2] && i.ops.pop(), i.trys.pop();
            continue;
        }
        c = e.call(t, i);
      } catch (u) {
        c = [
          6,
          u
        ], r = 0;
      } finally {
        n = o = 0;
      }
    if (c[0] & 5)
      throw c[1];
    return {
      value: c[0] ? c[1] : void 0,
      done: !0
    };
  }
}
function safeWrapper(t, e) {
  return _safeWrapper.apply(this, arguments);
}
function _safeWrapper() {
  return _safeWrapper = _async_to_generator$1(function(t, e) {
    var n, r;
    return _ts_generator$1(this, function(o) {
      switch (o.label) {
        case 0:
          return o.trys.push([
            0,
            2,
            ,
            3
          ]), [
            4,
            t()
          ];
        case 1:
          return n = o.sent(), [
            2,
            n
          ];
        case 2:
          return r = o.sent(), !e && warn(r), [
            2
          ];
        case 3:
          return [
            2
          ];
      }
    });
  }), _safeWrapper.apply(this, arguments);
}
function isStaticResourcesEqual(t, e) {
  var n = /^(https?:)?\/\//i, r = t.replace(n, "").replace(/\/$/, ""), o = e.replace(n, "").replace(/\/$/, "");
  return r === o;
}
function createScript(t, e, n, r) {
  for (var o = null, s = !0, i = document.getElementsByTagName("script"), a = 0; a < i.length; a++) {
    var l = i[a], c = l.getAttribute("src");
    if (c && isStaticResourcesEqual(c, t)) {
      o = l, s = !1;
      break;
    }
  }
  if (!o && (o = document.createElement("script"), o.type = "text/javascript", o.src = t, r)) {
    var u = r(t);
    _instanceof(u, HTMLScriptElement) && (o = u);
  }
  n && Object.keys(n).forEach(function(h) {
    o && (h === "async" || h === "defer" ? o[h] = n[h] : o.setAttribute(h, n[h]));
  });
  var d = function(h, M) {
    if (o && (o.onerror = null, o.onload = null, safeWrapper(function() {
      o != null && o.parentNode && o.parentNode.removeChild(o);
    }), h)) {
      var I = h(M);
      return e(), I;
    }
    e();
  };
  return o.onerror = d.bind(null, o.onerror), o.onload = d.bind(null, o.onload), {
    script: o,
    needAttach: s
  };
}
function createLink(t, e) {
  for (var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, r = arguments.length > 3 ? arguments[3] : void 0, o = null, s = !0, i = document.getElementsByTagName("link"), a = 0; a < i.length; a++) {
    var l = i[a], c = l.getAttribute("href"), u = l.getAttribute("ref");
    if (c && isStaticResourcesEqual(c, t) && u === n.ref) {
      o = l, s = !1;
      break;
    }
  }
  if (!o && (o = document.createElement("link"), o.setAttribute("href", t), r)) {
    var d = r(t);
    _instanceof(d, HTMLLinkElement) && (o = d);
  }
  n && Object.keys(n).forEach(function(M) {
    o && o.setAttribute(M, n[M]);
  });
  var h = function(M, I) {
    if (o && (o.onerror = null, o.onload = null, safeWrapper(function() {
      o != null && o.parentNode && o.parentNode.removeChild(o);
    }), M)) {
      var m = M(I);
      return e(), m;
    }
    e();
  };
  return o.onerror = h.bind(null, o.onerror), o.onload = h.bind(null, o.onload), {
    link: o,
    needAttach: s
  };
}
function loadScript(t, e) {
  var n = e.attrs, r = e.createScriptHook;
  return new Promise(function(o, s) {
    var i = createScript(t, o, n, r), a = i.script, l = i.needAttach;
    l && document.getElementsByTagName("head")[0].appendChild(a);
  });
}
function _array_like_to_array(t, e) {
  (e == null || e > t.length) && (e = t.length);
  for (var n = 0, r = new Array(e); n < e; n++)
    r[n] = t[n];
  return r;
}
function _array_with_holes(t) {
  if (Array.isArray(t))
    return t;
}
function asyncGeneratorStep(t, e, n, r, o, s, i) {
  try {
    var a = t[s](i), l = a.value;
  } catch (c) {
    n(c);
    return;
  }
  a.done ? e(l) : Promise.resolve(l).then(r, o);
}
function _async_to_generator(t) {
  return function() {
    var e = this, n = arguments;
    return new Promise(function(r, o) {
      var s = t.apply(e, n);
      function i(l) {
        asyncGeneratorStep(s, r, o, i, a, "next", l);
      }
      function a(l) {
        asyncGeneratorStep(s, r, o, i, a, "throw", l);
      }
      i(void 0);
    });
  };
}
function _iterable_to_array_limit(t, e) {
  var n = t == null ? null : typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"];
  if (n != null) {
    var r = [], o = !0, s = !1, i, a;
    try {
      for (n = n.call(t); !(o = (i = n.next()).done) && (r.push(i.value), !(e && r.length === e)); o = !0)
        ;
    } catch (l) {
      s = !0, a = l;
    } finally {
      try {
        !o && n.return != null && n.return();
      } finally {
        if (s)
          throw a;
      }
    }
    return r;
  }
}
function _non_iterable_rest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _sliced_to_array(t, e) {
  return _array_with_holes(t) || _iterable_to_array_limit(t, e) || _unsupported_iterable_to_array(t, e) || _non_iterable_rest();
}
function _unsupported_iterable_to_array(t, e) {
  if (!!t) {
    if (typeof t == "string")
      return _array_like_to_array(t, e);
    var n = Object.prototype.toString.call(t).slice(8, -1);
    if (n === "Object" && t.constructor && (n = t.constructor.name), n === "Map" || n === "Set")
      return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _array_like_to_array(t, e);
  }
}
function _ts_generator(t, e) {
  var n, r, o, s, i = {
    label: 0,
    sent: function() {
      if (o[0] & 1)
        throw o[1];
      return o[1];
    },
    trys: [],
    ops: []
  };
  return s = {
    next: a(0),
    throw: a(1),
    return: a(2)
  }, typeof Symbol == "function" && (s[Symbol.iterator] = function() {
    return this;
  }), s;
  function a(c) {
    return function(u) {
      return l([
        c,
        u
      ]);
    };
  }
  function l(c) {
    if (n)
      throw new TypeError("Generator is already executing.");
    for (; i; )
      try {
        if (n = 1, r && (o = c[0] & 2 ? r.return : c[0] ? r.throw || ((o = r.return) && o.call(r), 0) : r.next) && !(o = o.call(r, c[1])).done)
          return o;
        switch (r = 0, o && (c = [
          c[0] & 2,
          o.value
        ]), c[0]) {
          case 0:
          case 1:
            o = c;
            break;
          case 4:
            return i.label++, {
              value: c[1],
              done: !1
            };
          case 5:
            i.label++, r = c[1], c = [
              0
            ];
            continue;
          case 7:
            c = i.ops.pop(), i.trys.pop();
            continue;
          default:
            if (o = i.trys, !(o = o.length > 0 && o[o.length - 1]) && (c[0] === 6 || c[0] === 2)) {
              i = 0;
              continue;
            }
            if (c[0] === 3 && (!o || c[1] > o[0] && c[1] < o[3])) {
              i.label = c[1];
              break;
            }
            if (c[0] === 6 && i.label < o[1]) {
              i.label = o[1], o = c;
              break;
            }
            if (o && i.label < o[2]) {
              i.label = o[2], i.ops.push(c);
              break;
            }
            o[2] && i.ops.pop(), i.trys.pop();
            continue;
        }
        c = e.call(t, i);
      } catch (u) {
        c = [
          6,
          u
        ], r = 0;
      } finally {
        n = o = 0;
      }
    if (c[0] & 5)
      throw c[1];
    return {
      value: c[0] ? c[1] : void 0,
      done: !0
    };
  }
}
function importNodeModule(t) {
  if (!t)
    throw new Error("import specifier is required");
  var e = new Function("name", "return import(name)");
  return e(t).then(function(n) {
    return n.default;
  }).catch(function(n) {
    throw console.error("Error importing module ".concat(t, ":"), n), n;
  });
}
function createScriptNode(url, cb, attrs, createScriptHook) {
  if (createScriptHook) {
    var hookResult = createScriptHook(url);
    hookResult && typeof hookResult == "object" && "url" in hookResult && (url = hookResult.url);
  }
  var urlObj;
  try {
    urlObj = new URL(url);
  } catch (t) {
    console.error("Error constructing URL:", t), cb(new Error("Invalid URL: ".concat(t)));
    return;
  }
  var getFetch = function() {
    var t = _async_to_generator(function() {
      var e;
      return _ts_generator(this, function(n) {
        switch (n.label) {
          case 0:
            return typeof fetch > "u" ? [
              4,
              importNodeModule("node-fetch")
            ] : [
              3,
              2
            ];
          case 1:
            return e = n.sent(), [
              2,
              (e == null ? void 0 : e.default) || e
            ];
          case 2:
            return [
              2,
              fetch
            ];
          case 3:
            return [
              2
            ];
        }
      });
    });
    return function() {
      return t.apply(this, arguments);
    };
  }();
  console.log("fetching", urlObj.href), getFetch().then(function(f) {
    f(urlObj.href).then(function(t) {
      return t.text();
    }).then(function() {
      var _ref = _async_to_generator(function(data) {
        var _ref, path, vm, scriptContext, urlDirname, filename, script, exportedInterface, container;
        return _ts_generator(this, function(_state) {
          switch (_state.label) {
            case 0:
              return [
                4,
                Promise.all([
                  importNodeModule("path"),
                  importNodeModule("vm")
                ])
              ];
            case 1:
              _ref = _sliced_to_array.apply(void 0, [
                _state.sent(),
                2
              ]), path = _ref[0], vm = _ref[1], scriptContext = {
                exports: {},
                module: {
                  exports: {}
                }
              }, urlDirname = urlObj.pathname.split("/").slice(0, -1).join("/"), filename = path.basename(urlObj.pathname);
              try {
                if (script = new vm.Script("(function(exports, module, require, __dirname, __filename) {".concat(data, `
})`), filename), script.runInThisContext()(scriptContext.exports, scriptContext.module, eval("require"), urlDirname, filename), exportedInterface = scriptContext.module.exports || scriptContext.exports, attrs && exportedInterface && attrs.globalName)
                  return container = exportedInterface[attrs.globalName] || exportedInterface, cb(void 0, container), [
                    2
                  ];
                cb(void 0, exportedInterface);
              } catch (t) {
                cb(new Error("Script execution error: ".concat(t)));
              }
              return [
                2
              ];
          }
        });
      });
      return function(t) {
        return _ref.apply(this, arguments);
      };
    }()).catch(function(t) {
      cb(t);
    });
  });
}
function loadScriptNode(t, e) {
  return new Promise(function(n, r) {
    createScriptNode(t, function(o, s) {
      if (o)
        r(o);
      else {
        var i, a, l = (e == null || (i = e.attrs) === null || i === void 0 ? void 0 : i.globalName) || "__FEDERATION_".concat(e == null || (a = e.attrs) === null || a === void 0 ? void 0 : a.name, ":custom__"), c = globalThis[l] = s;
        n(c);
      }
    }, e.attrs, e.createScriptHook);
  });
}
function matchRemoteWithNameAndExpose(t, e) {
  for (const n of t) {
    const r = e.startsWith(n.name);
    let o = e.replace(n.name, "");
    if (r) {
      if (o.startsWith("/")) {
        const a = n.name;
        return o = `.${o}`, {
          pkgNameOrAlias: a,
          expose: o,
          remote: n
        };
      } else if (o === "")
        return {
          pkgNameOrAlias: n.name,
          expose: ".",
          remote: n
        };
    }
    const s = n.alias && e.startsWith(n.alias);
    let i = n.alias && e.replace(n.alias, "");
    if (n.alias && s) {
      if (i && i.startsWith("/")) {
        const a = n.alias;
        return i = `.${i}`, {
          pkgNameOrAlias: a,
          expose: i,
          remote: n
        };
      } else if (i === "")
        return {
          pkgNameOrAlias: n.alias,
          expose: ".",
          remote: n
        };
    }
  }
}
function matchRemote(t, e) {
  for (const n of t)
    if (e === n.name || n.alias && e === n.alias)
      return n;
}
function registerPlugins(t, e) {
  const n = getGlobalHostPlugins();
  n.length > 0 && n.forEach((r) => {
    t != null && t.find((o) => o.name !== r.name) && t.push(r);
  }), t && t.length > 0 && t.forEach((r) => {
    e.forEach((o) => {
      o.applyPlugin(r);
    });
  });
}
function _extends$5() {
  return _extends$5 = Object.assign || function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]);
    }
    return t;
  }, _extends$5.apply(this, arguments);
}
async function loadEsmEntry({ entry: t, remoteEntryExports: e }) {
  return new Promise((n, r) => {
    try {
      e ? n(e) : new Function("callbacks", `import("${t}").then(callbacks[0]).catch(callbacks[1])`)([
        n,
        r
      ]);
    } catch (o) {
      r(o);
    }
  });
}
async function loadEntryScript({ name: t, globalName: e, entry: n, createScriptHook: r }) {
  const { entryExports: o } = getRemoteEntryExports(t, e);
  return o || (typeof document > "u" ? loadScriptNode(n, {
    attrs: {
      name: t,
      globalName: e
    },
    createScriptHook: r
  }).then(() => {
    const { remoteEntryKey: s, entryExports: i } = getRemoteEntryExports(t, e);
    return assert(i, `
        Unable to use the ${t}'s '${n}' URL with ${s}'s globalName to get remoteEntry exports.
        Possible reasons could be:

        1. '${n}' is not the correct URL, or the remoteEntry resource or name is incorrect.

        2. ${s} cannot be used to get remoteEntry exports in the window object.
      `), i;
  }).catch((s) => s) : loadScript(n, {
    attrs: {},
    createScriptHook: r
  }).then(() => {
    const { remoteEntryKey: s, entryExports: i } = getRemoteEntryExports(t, e);
    return assert(i, `
      Unable to use the ${t}'s '${n}' URL with ${s}'s globalName to get remoteEntry exports.
      Possible reasons could be:

      1. '${n}' is not the correct URL, or the remoteEntry resource or name is incorrect.

      2. ${s} cannot be used to get remoteEntry exports in the window object.
    `), i;
  }).catch((s) => s));
}
function getRemoteEntryUniqueKey(t) {
  const { entry: e, name: n } = t;
  return composeKeyWithSeparator(n, e);
}
async function getRemoteEntry({ remoteEntryExports: t, remoteInfo: e, createScriptHook: n }) {
  const { entry: r, name: o, type: s, entryGlobalName: i } = e, a = getRemoteEntryUniqueKey(e);
  return t || (globalLoading[a] || (s === "esm" ? globalLoading[a] = loadEsmEntry({
    entry: r,
    remoteEntryExports: t
  }) : globalLoading[a] = loadEntryScript({
    name: o,
    globalName: i,
    entry: r,
    createScriptHook: n
  })), globalLoading[a]);
}
function getRemoteInfo(t) {
  return _extends$5({}, t, {
    entry: "entry" in t ? t.entry : "",
    type: t.type || DEFAULT_REMOTE_TYPE,
    entryGlobalName: t.entryGlobalName || t.name,
    shareScope: t.shareScope || DEFAULT_SCOPE
  });
}
function _extends$4() {
  return _extends$4 = Object.assign || function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]);
    }
    return t;
  }, _extends$4.apply(this, arguments);
}
let Module = class {
  async getEntry() {
    if (this.remoteEntryExports)
      return this.remoteEntryExports;
    const e = await getRemoteEntry({
      remoteInfo: this.remoteInfo,
      remoteEntryExports: this.remoteEntryExports,
      createScriptHook: (n) => {
        const r = this.host.loaderHook.lifecycle.createScript.emit({
          url: n
        });
        if (typeof document > "u" || r instanceof HTMLScriptElement)
          return r;
      }
    });
    return assert(e, `remoteEntryExports is undefined 
 ${safeToString$1(this.remoteInfo)}`), this.remoteEntryExports = e, this.remoteEntryExports;
  }
  async get(e, n) {
    const { loadFactory: r = !0 } = n || {
      loadFactory: !0
    }, o = await this.getEntry();
    if (!this.inited) {
      const a = this.host.shareScopeMap, l = this.remoteInfo.shareScope || "default";
      a[l] || (a[l] = {});
      const c = a[l], u = [], d = {
        version: this.remoteInfo.version || ""
      };
      Object.defineProperty(d, "hostId", {
        value: this.host.options.id || this.host.name,
        enumerable: !1
      });
      const h = await this.host.hooks.lifecycle.beforeInitContainer.emit({
        shareScope: c,
        remoteEntryInitOptions: d,
        initScope: u,
        remoteInfo: this.remoteInfo,
        origin: this.host
      });
      await o.init(h.shareScope, h.initScope, h.remoteEntryInitOptions), await this.host.hooks.lifecycle.initContainer.emit(_extends$4({}, h, {
        remoteEntryExports: o
      }));
    }
    this.lib = o, this.inited = !0;
    const s = await o.get(e);
    return assert(s, `${getFMId(this.remoteInfo)} remote don't export ${e}.`), r ? await s() : s;
  }
  constructor({ remoteInfo: e, host: n }) {
    this.inited = !1, this.lib = void 0, this.remoteInfo = e, this.host = n;
  }
};
class SyncHook {
  on(e) {
    typeof e == "function" && this.listeners.add(e);
  }
  once(e) {
    const n = this;
    this.on(function r(...o) {
      return n.remove(r), e.apply(null, o);
    });
  }
  emit(...e) {
    let n;
    return this.listeners.size > 0 && this.listeners.forEach((r) => {
      n = r(...e);
    }), n;
  }
  remove(e) {
    this.listeners.delete(e);
  }
  removeAll() {
    this.listeners.clear();
  }
  constructor(e) {
    this.type = "", this.listeners = /* @__PURE__ */ new Set(), e && (this.type = e);
  }
}
class AsyncHook extends SyncHook {
  emit(...e) {
    let n;
    const r = Array.from(this.listeners);
    if (r.length > 0) {
      let o = 0;
      const s = (i) => i === !1 ? !1 : o < r.length ? Promise.resolve(r[o++].apply(null, e)).then(s) : i;
      n = s();
    }
    return Promise.resolve(n);
  }
}
function checkReturnData(t, e) {
  if (!isObject(e))
    return !1;
  if (t !== e) {
    for (const n in t)
      if (!(n in e))
        return !1;
  }
  return !0;
}
class SyncWaterfallHook extends SyncHook {
  emit(e) {
    isObject(e) || error(`The data for the "${this.type}" hook should be an object.`);
    for (const n of this.listeners)
      try {
        const r = n(e);
        if (checkReturnData(e, r))
          e = r;
        else {
          this.onerror(`A plugin returned an unacceptable value for the "${this.type}" type.`);
          break;
        }
      } catch (r) {
        warn$1(r), this.onerror(r);
      }
    return e;
  }
  constructor(e) {
    super(), this.onerror = error, this.type = e;
  }
}
class AsyncWaterfallHook extends SyncHook {
  emit(e) {
    isObject(e) || error(`The response data for the "${this.type}" hook must be an object.`);
    const n = Array.from(this.listeners);
    if (n.length > 0) {
      let r = 0;
      const o = (i) => (warn$1(i), this.onerror(i), e), s = (i) => {
        if (checkReturnData(e, i)) {
          if (e = i, r < n.length)
            try {
              return Promise.resolve(n[r++](e)).then(s, o);
            } catch (a) {
              return o(a);
            }
        } else
          this.onerror(`A plugin returned an incorrect value for the "${this.type}" type.`);
        return e;
      };
      return Promise.resolve(s(e));
    }
    return Promise.resolve(e);
  }
  constructor(e) {
    super(), this.onerror = error, this.type = e;
  }
}
class PluginSystem {
  applyPlugin(e) {
    assert(isPlainObject(e), "Plugin configuration is invalid.");
    const n = e.name;
    assert(n, "A name must be provided by the plugin."), this.registerPlugins[n] || (this.registerPlugins[n] = e, Object.keys(this.lifecycle).forEach((r) => {
      const o = e[r];
      o && this.lifecycle[r].on(o);
    }));
  }
  removePlugin(e) {
    assert(e, "A name is required.");
    const n = this.registerPlugins[e];
    assert(n, `The plugin "${e}" is not registered.`), Object.keys(n).forEach((r) => {
      r !== "name" && this.lifecycle[r].remove(n[r]);
    });
  }
  inherit({ lifecycle: e, registerPlugins: n }) {
    Object.keys(e).forEach((r) => {
      assert(!this.lifecycle[r], `The hook "${r}" has a conflict and cannot be inherited.`), this.lifecycle[r] = e[r];
    }), Object.keys(n).forEach((r) => {
      assert(!this.registerPlugins[r], `The plugin "${r}" has a conflict and cannot be inherited.`), this.applyPlugin(n[r]);
    });
  }
  constructor(e) {
    this.registerPlugins = {}, this.lifecycle = e, this.lifecycleKeys = Object.keys(e);
  }
}
function _extends$3() {
  return _extends$3 = Object.assign || function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]);
    }
    return t;
  }, _extends$3.apply(this, arguments);
}
function defaultPreloadArgs(t) {
  return _extends$3({
    resourceCategory: "sync",
    share: !0,
    depsRemote: !0,
    prefetchInterface: !1
  }, t);
}
function formatPreloadArgs(t, e) {
  return e.map((n) => {
    const r = matchRemote(t, n.nameOrAlias);
    return assert(r, `Unable to preload ${n.nameOrAlias} as it is not included in ${!r && safeToString$1({
      remoteInfo: r,
      remotes: t
    })}`), {
      remote: r,
      preloadConfig: defaultPreloadArgs(n)
    };
  });
}
function normalizePreloadExposes(t) {
  return t ? t.map((e) => e === "." ? e : e.startsWith("./") ? e.replace("./", "") : e) : [];
}
function preloadAssets(t, e, n) {
  const { cssAssets: r, jsAssetsWithoutEntry: o, entryAssets: s } = n;
  if (e.options.inBrowser) {
    s.forEach((a) => {
      const { moduleInfo: l } = a, c = e.moduleCache.get(t.name);
      getRemoteEntry(c ? {
        remoteInfo: l,
        remoteEntryExports: c.remoteEntryExports,
        createScriptHook: (u) => {
          const d = e.loaderHook.lifecycle.createScript.emit({
            url: u
          });
          if (d instanceof HTMLScriptElement)
            return d;
        }
      } : {
        remoteInfo: l,
        remoteEntryExports: void 0,
        createScriptHook: (u) => {
          const d = e.loaderHook.lifecycle.createScript.emit({
            url: u
          });
          if (d instanceof HTMLScriptElement)
            return d;
        }
      });
    });
    const i = document.createDocumentFragment();
    r.forEach((a) => {
      const { link: l, needAttach: c } = createLink(a, () => {
      }, {
        rel: "preload",
        as: "style"
      }, (u) => {
        const d = e.loaderHook.lifecycle.createLink.emit({
          url: u
        });
        if (d instanceof HTMLLinkElement)
          return d;
      });
      c && i.appendChild(l);
    }), o.forEach((a) => {
      const { link: l, needAttach: c } = createLink(a, () => {
      }, {
        rel: "preload",
        as: "script"
      }, (u) => {
        const d = e.loaderHook.lifecycle.createLink.emit({
          url: u
        });
        if (d instanceof HTMLLinkElement)
          return d;
      });
      c && document.head.appendChild(l);
    }), document.head.appendChild(i);
  }
}
function _extends$2() {
  return _extends$2 = Object.assign || function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]);
    }
    return t;
  }, _extends$2.apply(this, arguments);
}
function assignRemoteInfo(t, e) {
  (!("remoteEntry" in e) || !e.remoteEntry) && error(`The attribute remoteEntry of ${name} must not be undefined.`);
  const { remoteEntry: n } = e, r = getResourceUrl(e, n);
  t.type = e.remoteEntryType, t.entryGlobalName = e.globalName, t.entry = r, t.version = e.version, t.buildVersion = e.buildVersion;
}
function snapshotPlugin() {
  return {
    name: "snapshot-plugin",
    async afterResolve(t) {
      const { remote: e, pkgNameOrAlias: n, expose: r, origin: o, remoteInfo: s } = t;
      if (!isRemoteInfoWithEntry(e) || !isPureRemoteEntry(e)) {
        const { remoteSnapshot: i, globalSnapshot: a } = await o.snapshotHandler.loadRemoteSnapshotInfo(e);
        assignRemoteInfo(s, i);
        const l = {
          remote: e,
          preloadConfig: {
            nameOrAlias: n,
            exposes: [
              r
            ],
            resourceCategory: "sync",
            share: !1,
            depsRemote: !1
          }
        }, c = await o.hooks.lifecycle.generatePreloadAssets.emit({
          origin: o,
          preloadOptions: l,
          remoteInfo: s,
          remote: e,
          remoteSnapshot: i,
          globalSnapshot: a
        });
        return c && preloadAssets(s, o, c), _extends$2({}, t, {
          remoteSnapshot: i
        });
      }
      return t;
    }
  };
}
function splitId(t) {
  const e = t.split(":");
  return e.length === 1 ? {
    name: e[0],
    version: void 0
  } : e.length === 2 ? {
    name: e[0],
    version: e[1]
  } : {
    name: e[1],
    version: e[2]
  };
}
function traverseModuleInfo(t, e, n, r, o = {}, s) {
  const i = getFMId(e), { value: a } = getInfoWithoutType(t, i), l = s || a;
  if (l && !isManifestProvider(l) && (n(l, e, r), l.remotesInfo)) {
    const c = Object.keys(l.remotesInfo);
    for (const u of c) {
      if (o[u])
        continue;
      o[u] = !0;
      const d = splitId(u), h = l.remotesInfo[u];
      traverseModuleInfo(t, {
        name: d.name,
        version: h.matchedVersion
      }, n, !1, o, void 0);
    }
  }
}
function generatePreloadAssets(t, e, n, r, o) {
  const s = [], i = [], a = [], l = /* @__PURE__ */ new Set(), c = /* @__PURE__ */ new Set(), { options: u } = t, { preloadConfig: d } = e, { depsRemote: h } = d;
  traverseModuleInfo(r, n, (g, p, E) => {
    let y;
    if (E)
      y = d;
    else if (Array.isArray(h)) {
      const A = h.find((_) => _.nameOrAlias === p.name || _.nameOrAlias === p.alias);
      if (!A)
        return;
      y = defaultPreloadArgs(A);
    } else if (h === !0)
      y = d;
    else
      return;
    const S = getResourceUrl(g, "remoteEntry" in g ? g.remoteEntry : "");
    S && a.push({
      name: p.name,
      moduleInfo: {
        name: p.name,
        entry: S,
        type: "remoteEntryType" in g ? g.remoteEntryType : "global",
        entryGlobalName: "globalName" in g ? g.globalName : p.name,
        shareScope: "",
        version: "version" in g ? g.version : void 0
      },
      url: S
    });
    let z = "modules" in g ? g.modules : [];
    const v = normalizePreloadExposes(y.exposes);
    if (v.length && "modules" in g) {
      var w;
      z = g == null || (w = g.modules) == null ? void 0 : w.reduce((A, _) => ((v == null ? void 0 : v.indexOf(_.moduleName)) !== -1 && A.push(_), A), []);
    }
    function O(A) {
      const _ = A.map((D) => getResourceUrl(g, D));
      return y.filter ? _.filter(y.filter) : _;
    }
    if (z) {
      const A = z.length;
      for (let _ = 0; _ < A; _++) {
        const D = z[_], R = `${p.name}/${D.moduleName}`;
        t.hooks.lifecycle.handlePreloadModule.emit({
          id: D.moduleName === "." ? p.name : R,
          name: p.name,
          remoteSnapshot: g,
          preloadConfig: y,
          remote: p,
          origin: t
        }), !getPreloaded(R) && (y.resourceCategory === "all" ? (s.push(...O(D.assets.css.async)), s.push(...O(D.assets.css.sync)), i.push(...O(D.assets.js.async)), i.push(...O(D.assets.js.sync))) : (y.resourceCategory = "sync") && (s.push(...O(D.assets.css.sync)), i.push(...O(D.assets.js.sync))), setPreloaded(R));
      }
    }
  }, !0, {}, o), o.shared && o.shared.forEach((g) => {
    var p;
    const E = (p = u.shared) == null ? void 0 : p[g.sharedName];
    if (!E)
      return;
    const y = getRegisteredShare(t.shareScopeMap, g.sharedName, E, t.hooks.lifecycle.resolveShare);
    y && typeof y.lib == "function" && (g.assets.js.sync.forEach((S) => {
      l.add(S);
    }), g.assets.css.sync.forEach((S) => {
      c.add(S);
    }));
  });
  const I = i.filter((g) => !l.has(g));
  return {
    cssAssets: s.filter((g) => !c.has(g)),
    jsAssetsWithoutEntry: I,
    entryAssets: a
  };
}
const generatePreloadAssetsPlugin = function() {
  return {
    name: "generate-preload-assets-plugin",
    async generatePreloadAssets(t) {
      const { origin: e, preloadOptions: n, remoteInfo: r, remote: o, globalSnapshot: s, remoteSnapshot: i } = t;
      return isRemoteInfoWithEntry(o) && isPureRemoteEntry(o) ? {
        cssAssets: [],
        jsAssetsWithoutEntry: [],
        entryAssets: [
          {
            name: o.name,
            url: o.entry,
            moduleInfo: {
              name: r.name,
              entry: o.entry,
              type: "global",
              entryGlobalName: "",
              shareScope: ""
            }
          }
        ]
      } : (assignRemoteInfo(r, i), generatePreloadAssets(e, n, r, s, i));
    }
  };
};
function _extends$1() {
  return _extends$1 = Object.assign || function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]);
    }
    return t;
  }, _extends$1.apply(this, arguments);
}
class SnapshotHandler {
  async loadSnapshot(e) {
    const { options: n } = this.HostInstance, { hostGlobalSnapshot: r, remoteSnapshot: o, globalSnapshot: s } = this.getGlobalRemoteInfo(e), { remoteSnapshot: i, globalSnapshot: a } = await this.hooks.lifecycle.loadSnapshot.emit({
      options: n,
      moduleInfo: e,
      hostGlobalSnapshot: r,
      remoteSnapshot: o,
      globalSnapshot: s
    });
    return {
      remoteSnapshot: i,
      globalSnapshot: a
    };
  }
  async loadRemoteSnapshotInfo(e) {
    const { options: n } = this.HostInstance;
    await this.hooks.lifecycle.beforeLoadRemoteSnapshot.emit({
      options: n,
      moduleInfo: e
    });
    let r = getGlobalSnapshotInfoByModuleInfo({
      name: this.HostInstance.options.name,
      version: this.HostInstance.options.version
    });
    r || (r = {
      version: this.HostInstance.options.version || "",
      remoteEntry: "",
      remotesInfo: {}
    }, addGlobalSnapshot({
      [this.HostInstance.options.name]: r
    })), r && "remotesInfo" in r && !getInfoWithoutType(r.remotesInfo, e.name).value && ("version" in e || "entry" in e) && (r.remotesInfo = _extends$1({}, r == null ? void 0 : r.remotesInfo, {
      [e.name]: {
        matchedVersion: "version" in e ? e.version : e.entry
      }
    }));
    const { hostGlobalSnapshot: o, remoteSnapshot: s, globalSnapshot: i } = this.getGlobalRemoteInfo(e), { remoteSnapshot: a, globalSnapshot: l } = await this.hooks.lifecycle.loadSnapshot.emit({
      options: n,
      moduleInfo: e,
      hostGlobalSnapshot: o,
      remoteSnapshot: s,
      globalSnapshot: i
    });
    if (a)
      if (isManifestProvider(a)) {
        const c = await this.getManifestJson(a.remoteEntry, e, {}), u = setGlobalSnapshotInfoByModuleInfo(_extends$1({}, e, {
          entry: a.remoteEntry
        }), c);
        return {
          remoteSnapshot: c,
          globalSnapshot: u
        };
      } else {
        const { remoteSnapshot: c } = await this.hooks.lifecycle.loadRemoteSnapshot.emit({
          options: this.HostInstance.options,
          moduleInfo: e,
          remoteSnapshot: a,
          from: "global"
        });
        return {
          remoteSnapshot: c,
          globalSnapshot: l
        };
      }
    else if (isRemoteInfoWithEntry(e)) {
      const c = await this.getManifestJson(e.entry, e, {}), u = setGlobalSnapshotInfoByModuleInfo(e, c), { remoteSnapshot: d } = await this.hooks.lifecycle.loadRemoteSnapshot.emit({
        options: this.HostInstance.options,
        moduleInfo: e,
        remoteSnapshot: c,
        from: "global"
      });
      return {
        remoteSnapshot: d,
        globalSnapshot: u
      };
    } else
      error(`
          Cannot get remoteSnapshot with the name: '${e.name}', version: '${e.version}' from __FEDERATION__.moduleInfo. The following reasons may be causing the problem:

          1. The Deploy platform did not deliver the correct data. You can use __FEDERATION__.moduleInfo to check the remoteInfo.

          2. The remote '${e.name}' version '${e.version}' is not released.

          The transformed module info: ${JSON.stringify(l)}
        `);
  }
  getGlobalRemoteInfo(e) {
    const n = getGlobalSnapshotInfoByModuleInfo({
      name: this.HostInstance.options.name,
      version: this.HostInstance.options.version
    }), r = n && "remotesInfo" in n && n.remotesInfo && getInfoWithoutType(n.remotesInfo, e.name).value;
    return r && r.matchedVersion ? {
      hostGlobalSnapshot: n,
      globalSnapshot: getGlobalSnapshot(),
      remoteSnapshot: getGlobalSnapshotInfoByModuleInfo({
        name: e.name,
        version: r.matchedVersion
      })
    } : {
      hostGlobalSnapshot: void 0,
      globalSnapshot: getGlobalSnapshot(),
      remoteSnapshot: getGlobalSnapshotInfoByModuleInfo({
        name: e.name,
        version: "version" in e ? e.version : void 0
      })
    };
  }
  async getManifestJson(e, n, r) {
    const o = async () => {
      let i = this.manifestCache.get(e);
      if (i)
        return i;
      try {
        let a = await this.loaderHook.lifecycle.fetch.emit(e, {});
        return (!a || !(a instanceof Response)) && (a = await fetch(e, {})), i = await a.json(), assert(i.metaData && i.exposes && i.shared, `${e} is not a federation manifest`), this.manifestCache.set(e, i), i;
      } catch (a) {
        error(`Failed to get manifestJson for ${n.name}. The manifest URL is ${e}. Please ensure that the manifestUrl is accessible.
          
 Error message:
          
 ${a}`);
      }
    }, s = async () => {
      const i = await o(), a = generateSnapshotFromManifest(i, {
        version: e
      }), { remoteSnapshot: l } = await this.hooks.lifecycle.loadRemoteSnapshot.emit({
        options: this.HostInstance.options,
        moduleInfo: n,
        manifestJson: i,
        remoteSnapshot: a,
        manifestUrl: e,
        from: "manifest"
      });
      return l;
    };
    return this.manifestLoading[e] || (this.manifestLoading[e] = s().then((i) => i)), this.manifestLoading[e];
  }
  constructor(e) {
    this.loadingHostSnapshot = null, this.manifestCache = /* @__PURE__ */ new Map(), this.hooks = new PluginSystem({
      beforeLoadRemoteSnapshot: new AsyncHook("beforeLoadRemoteSnapshot"),
      loadSnapshot: new AsyncWaterfallHook("loadGlobalSnapshot"),
      loadRemoteSnapshot: new AsyncWaterfallHook("loadRemoteSnapshot")
    }), this.manifestLoading = Global.__FEDERATION__.__MANIFEST_LOADING__, this.HostInstance = e, this.loaderHook = e.loaderHook;
  }
}
function _extends() {
  return _extends = Object.assign || function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]);
    }
    return t;
  }, _extends.apply(this, arguments);
}
function _object_without_properties_loose(t, e) {
  if (t == null)
    return {};
  var n = {}, r = Object.keys(t), o, s;
  for (s = 0; s < r.length; s++)
    o = r[s], !(e.indexOf(o) >= 0) && (n[o] = t[o]);
  return n;
}
class FederationHost {
  _setGlobalShareScopeMap() {
    const e = getGlobalShareScope(), n = this.options.id || this.options.name;
    n && !e[n] && (e[n] = this.shareScopeMap);
  }
  initOptions(e) {
    this.registerPlugins(e.plugins);
    const n = this.formatOptions(this.options, e);
    return this.options = n, n;
  }
  async loadShare(e, n) {
    var r;
    const o = Object.assign({}, (r = this.options.shared) == null ? void 0 : r[e], n);
    o != null && o.scope && await Promise.all(o.scope.map(async (c) => {
      await Promise.all(this.initializeSharing(c, o.strategy));
    }));
    const s = await this.hooks.lifecycle.beforeLoadShare.emit({
      pkgName: e,
      shareInfo: o,
      shared: this.options.shared,
      origin: this
    }), { shareInfo: i } = s;
    assert(i, `Cannot find ${e} Share in the ${this.options.name}. Please ensure that the ${e} Share parameters have been injected`);
    const a = getRegisteredShare(this.shareScopeMap, e, i, this.hooks.lifecycle.resolveShare), l = (c) => {
      c.useIn || (c.useIn = []), addUniqueItem(c.useIn, this.options.name);
    };
    if (a && a.lib)
      return l(a), a.lib;
    if (a && a.loading && !a.loaded) {
      const c = await a.loading;
      return a.loaded = !0, a.lib || (a.lib = c), l(a), c;
    } else if (a) {
      const u = (async () => {
        const d = await a.get();
        i.lib = d, i.loaded = !0, l(i);
        const h = getRegisteredShare(this.shareScopeMap, e, i, this.hooks.lifecycle.resolveShare);
        return h && (h.lib = d, h.loaded = !0), d;
      })();
      return this.setShared({
        pkgName: e,
        loaded: !1,
        shared: a,
        from: this.options.name,
        lib: null,
        loading: u
      }), u;
    } else {
      if (n)
        return !1;
      const u = (async () => {
        const d = await i.get();
        i.lib = d, i.loaded = !0, l(i);
        const h = getRegisteredShare(this.shareScopeMap, e, i, this.hooks.lifecycle.resolveShare);
        return h && (h.lib = d, h.loaded = !0), d;
      })();
      return this.setShared({
        pkgName: e,
        loaded: !1,
        shared: i,
        from: this.options.name,
        lib: null,
        loading: u
      }), u;
    }
  }
  loadShareSync(e, n) {
    var r;
    const o = Object.assign({}, (r = this.options.shared) == null ? void 0 : r[e], n);
    o != null && o.scope && o.scope.forEach((a) => {
      this.initializeSharing(a, o.strategy);
    });
    const s = getRegisteredShare(this.shareScopeMap, e, o, this.hooks.lifecycle.resolveShare), i = (a) => {
      a.useIn || (a.useIn = []), addUniqueItem(a.useIn, this.options.name);
    };
    if (s) {
      if (typeof s.lib == "function")
        return i(s), s.loaded || (s.loaded = !0, s.from === this.options.name && (o.loaded = !0)), s.lib;
      if (typeof s.get == "function") {
        const a = s.get();
        if (!(a instanceof Promise))
          return i(s), this.setShared({
            pkgName: e,
            loaded: !0,
            from: this.options.name,
            lib: a,
            shared: s
          }), a;
      }
    }
    if (o.lib)
      return o.loaded || (o.loaded = !0), o.lib;
    if (o.get) {
      const a = o.get();
      if (a instanceof Promise)
        throw new Error(`
        The loadShareSync function was unable to load ${e}. The ${e} could not be found in ${this.options.name}.
        Possible reasons for failure: 

        1. The ${e} share was registered with the 'get' attribute, but loadShare was not used beforehand.

        2. The ${e} share was not registered with the 'lib' attribute.

      `);
      return o.lib = a, this.setShared({
        pkgName: e,
        loaded: !0,
        from: this.options.name,
        lib: o.lib,
        shared: o
      }), o.lib;
    }
    throw new Error(`
        The loadShareSync function was unable to load ${e}. The ${e} could not be found in ${this.options.name}.
        Possible reasons for failure: 

        1. The ${e} share was registered with the 'get' attribute, but loadShare was not used beforehand.

        2. The ${e} share was not registered with the 'lib' attribute.

      `);
  }
  initRawContainer(e, n, r) {
    const o = getRemoteInfo({
      name: e,
      entry: n
    }), s = new Module({
      host: this,
      remoteInfo: o
    });
    return s.remoteEntryExports = r, this.moduleCache.set(e, s), s;
  }
  async _getRemoteModuleAndOptions(e) {
    const n = await this.hooks.lifecycle.beforeRequest.emit({
      id: e,
      options: this.options,
      origin: this
    }), { id: r } = n, o = matchRemoteWithNameAndExpose(this.options.remotes, r);
    assert(o, `
        Unable to locate ${r} in ${this.options.name}. Potential reasons for failure include:

        1. ${r} was not included in the 'remotes' parameter of ${this.options.name || "the host"}.

        2. ${r} could not be found in the 'remotes' of ${this.options.name} with either 'name' or 'alias' attributes.
        3. ${r} is not online, injected, or loaded.
        4. ${r}  cannot be accessed on the expected.
        5. The 'beforeRequest' hook was provided but did not return the correct 'remoteInfo' when attempting to load ${r}.
      `);
    const { remote: s } = o, i = getRemoteInfo(s), a = await this.hooks.lifecycle.afterResolve.emit(_extends({
      id: r
    }, o, {
      options: this.options,
      origin: this,
      remoteInfo: i
    })), { remote: l, expose: c } = a;
    assert(l && c, `The 'beforeRequest' hook was executed, but it failed to return the correct 'remote' and 'expose' values while loading ${r}.`);
    let u = this.moduleCache.get(l.name);
    const d = {
      host: this,
      remoteInfo: i
    };
    return u || (u = new Module(d), this.moduleCache.set(l.name, u)), {
      module: u,
      moduleOptions: d,
      remoteMatchInfo: a
    };
  }
  async loadRemote(e, n) {
    try {
      const { loadFactory: r = !0 } = n || {
        loadFactory: !0
      }, { module: o, moduleOptions: s, remoteMatchInfo: i } = await this._getRemoteModuleAndOptions(e), { pkgNameOrAlias: a, remote: l, expose: c, id: u } = i, d = await o.get(c, n), h = await this.hooks.lifecycle.onLoad.emit({
        id: u,
        pkgNameOrAlias: a,
        expose: c,
        exposeModule: r ? d : void 0,
        exposeModuleFactory: r ? void 0 : d,
        remote: l,
        options: s,
        moduleInstance: o,
        origin: this
      });
      return typeof h == "function" ? h : d;
    } catch (r) {
      const { from: o = "runtime" } = n || {
        from: "runtime"
      }, s = await this.hooks.lifecycle.errorLoadRemote.emit({
        id: e,
        error: r,
        from: o,
        origin: this
      });
      if (!s)
        throw r;
      return s;
    }
  }
  async preloadRemote(e) {
    await this.hooks.lifecycle.beforePreloadRemote.emit({
      preloadOptions: e,
      options: this.options,
      origin: this
    });
    const n = formatPreloadArgs(this.options.remotes, e);
    await Promise.all(n.map(async (r) => {
      const { remote: o } = r, s = getRemoteInfo(o), { globalSnapshot: i, remoteSnapshot: a } = await this.snapshotHandler.loadRemoteSnapshotInfo(o), l = await this.hooks.lifecycle.generatePreloadAssets.emit({
        origin: this,
        preloadOptions: r,
        remote: o,
        remoteInfo: s,
        globalSnapshot: i,
        remoteSnapshot: a
      });
      !l || preloadAssets(s, this, l);
    }));
  }
  initializeSharing(e = DEFAULT_SCOPE, n) {
    const r = this.shareScopeMap, o = this.options.name;
    r[e] || (r[e] = {});
    const s = r[e], i = (u, d) => {
      var h;
      const { version: M, eager: I } = d;
      s[u] = s[u] || {};
      const m = s[u], g = m[M], p = Boolean(g && (g.eager || ((h = g.shareConfig) == null ? void 0 : h.eager)));
      (!g || g.strategy !== "loaded-first" && !g.loaded && (Boolean(!I) !== !p ? I : o > g.from)) && (m[M] = d);
    }, a = [], l = (u) => u && u.init && u.init(r[e]), c = async (u) => {
      const { module: d } = await this._getRemoteModuleAndOptions(u);
      if (d.getEntry) {
        const h = await d.getEntry();
        d.inited || (l(h), d.inited = !0);
      }
    };
    return Object.keys(this.options.shared).forEach((u) => {
      const d = this.options.shared[u];
      d.scope.includes(e) && i(u, d);
    }), n === "version-first" && this.options.remotes.forEach((u) => {
      u.shareScope === e && a.push(c(u.name));
    }), a;
  }
  initShareScopeMap(e, n) {
    this.shareScopeMap[e] = n, this.hooks.lifecycle.initContainerShareScopeMap.emit({
      shareScope: n,
      options: this.options,
      origin: this
    });
  }
  formatOptions(e, n) {
    const r = formatShareConfigs(n.shared || {}, n.name), o = _extends({}, e.shared, r), { userOptions: s, options: i } = this.hooks.lifecycle.beforeInit.emit({
      origin: this,
      userOptions: n,
      options: e,
      shareInfo: o
    }), l = (s.remotes || []).reduce((h, M) => (this.registerRemote(M, h, {
      force: !1
    }), h), i.remotes);
    Object.keys(r).forEach((h) => {
      const M = r[h];
      !getRegisteredShare(this.shareScopeMap, h, M, this.hooks.lifecycle.resolveShare) && M && M.lib && this.setShared({
        pkgName: h,
        lib: M.lib,
        get: M.get,
        loaded: !0,
        shared: M,
        from: n.name
      });
    });
    const u = [
      ...i.plugins
    ];
    s.plugins && s.plugins.forEach((h) => {
      u.includes(h) || u.push(h);
    });
    const d = _extends({}, e, n, {
      plugins: u,
      remotes: l,
      shared: o
    });
    return this.hooks.lifecycle.init.emit({
      origin: this,
      options: d
    }), d;
  }
  registerPlugins(e) {
    registerPlugins(e, [
      this.hooks,
      this.snapshotHandler.hooks,
      this.loaderHook
    ]);
  }
  setShared({ pkgName: e, shared: n, from: r, lib: o, loading: s, loaded: i, get: a }) {
    const { version: l, scope: c = "default" } = n, u = _object_without_properties_loose(n, [
      "version",
      "scope"
    ]);
    (Array.isArray(c) ? c : [
      c
    ]).forEach((h) => {
      this.shareScopeMap[h] || (this.shareScopeMap[h] = {}), this.shareScopeMap[h][e] || (this.shareScopeMap[h][e] = {}), !this.shareScopeMap[h][e][l] && (this.shareScopeMap[h][e][l] = _extends({
        version: l,
        scope: [
          "default"
        ]
      }, u, {
        lib: o,
        loaded: i,
        loading: s
      }), a && (this.shareScopeMap[h][e][l].get = a));
    });
  }
  removeRemote(e) {
    const { name: n } = e, r = this.options.remotes.findIndex((s) => s.name === n);
    r !== -1 && this.options.remotes.splice(r, 1);
    const o = this.moduleCache.get(e.name);
    if (o) {
      const s = o.remoteInfo.entryGlobalName;
      globalThis[s] && delete globalThis[s];
      const i = getRemoteEntryUniqueKey(o.remoteInfo);
      globalLoading[i] && delete globalLoading[i], this.moduleCache.delete(e.name);
    }
  }
  registerRemote(e, n, r) {
    const o = () => {
      if (e.alias) {
        const i = n.find((a) => {
          var l;
          return e.alias && (a.name.startsWith(e.alias) || ((l = a.alias) == null ? void 0 : l.startsWith(e.alias)));
        });
        assert(!i, `The alias ${e.alias} of remote ${e.name} is not allowed to be the prefix of ${i && i.name} name or alias`);
      }
      "entry" in e && isBrowserEnv$1() && !e.entry.startsWith("http") && (e.entry = new URL(e.entry, window.location.origin).href), e.shareScope || (e.shareScope = DEFAULT_SCOPE), e.type || (e.type = DEFAULT_REMOTE_TYPE);
    }, s = n.find((i) => i.name === e.name);
    if (!s)
      o(), n.push(e);
    else {
      const i = [
        `The remote "${e.name}" is already registered.`,
        r != null && r.force ? "Hope you have known that OVERRIDE it may have some unexpected errors" : 'If you want to merge the remote, you can set "force: true".'
      ];
      r != null && r.force && (this.removeRemote(s), o(), n.push(e)), warn$1(i.join(" "));
    }
  }
  registerRemotes(e, n) {
    e.forEach((r) => {
      this.registerRemote(r, this.options.remotes, {
        force: n == null ? void 0 : n.force
      });
    });
  }
  constructor(e) {
    this.hooks = new PluginSystem({
      beforeInit: new SyncWaterfallHook("beforeInit"),
      init: new SyncHook(),
      beforeRequest: new AsyncWaterfallHook("beforeRequest"),
      afterResolve: new AsyncWaterfallHook("afterResolve"),
      beforeInitContainer: new AsyncWaterfallHook("beforeInitContainer"),
      initContainerShareScopeMap: new AsyncWaterfallHook("initContainer"),
      initContainer: new AsyncWaterfallHook("initContainer"),
      onLoad: new AsyncHook("onLoad"),
      handlePreloadModule: new SyncHook("handlePreloadModule"),
      errorLoadRemote: new AsyncHook("errorLoadRemote"),
      beforeLoadShare: new AsyncWaterfallHook("beforeLoadShare"),
      loadShare: new AsyncHook(),
      resolveShare: new SyncWaterfallHook("resolveShare"),
      beforePreloadRemote: new AsyncHook(),
      generatePreloadAssets: new AsyncHook("generatePreloadAssets"),
      afterPreloadRemote: new AsyncHook()
    }), this.version = "0.1.2", this.moduleCache = /* @__PURE__ */ new Map(), this.loaderHook = new PluginSystem({
      getModuleInfo: new SyncHook(),
      createScript: new SyncHook(),
      createLink: new SyncHook(),
      fetch: new AsyncHook("fetch")
    });
    const n = {
      id: getBuilderId(),
      name: e.name,
      plugins: [
        snapshotPlugin(),
        generatePreloadAssetsPlugin()
      ],
      remotes: [],
      shared: {},
      inBrowser: isBrowserEnv$1()
    };
    this.name = e.name, this.options = n, this.shareScopeMap = {}, this._setGlobalShareScopeMap(), this.snapshotHandler = new SnapshotHandler(this), this.registerPlugins([
      ...n.plugins,
      ...e.plugins || []
    ]), this.options = this.formatOptions(n, e);
  }
}
let FederationInstance = null;
function init(t) {
  const e = getGlobalFederationInstance(t.name, t.version);
  if (e)
    return e.initOptions(t), FederationInstance || (FederationInstance = e), e;
  {
    const n = getGlobalFederationConstructor() || FederationHost;
    return FederationInstance = new n(t), setGlobalFederationInstance(FederationInstance), FederationInstance;
  }
}
function loadRemote(...t) {
  return assert(FederationInstance, "Please call init first"), FederationInstance.loadRemote.apply(FederationInstance, t);
}
setGlobalFederationConstructor(FederationHost);
function isMetaMaskProvider(t) {
  return t !== null && typeof t == "object" && t.hasOwnProperty("isMetaMask") && t.hasOwnProperty("request");
}
function detectMetaMaskProvider(t, { timeout: e = 3e3 } = {}) {
  let n = !1;
  return new Promise((r) => {
    const o = (s) => {
      const { info: i, provider: a } = s.detail;
      ["io.metamask", "io.metamask.flask"].includes(i.rdns) && isMetaMaskProvider(a) && (r(a), n = !0);
    };
    typeof t.addEventListener == "function" && t.addEventListener(
      "eip6963:announceProvider",
      o
    ), setTimeout(() => {
      n || r(null);
    }, e), typeof t.dispatchEvent == "function" && t.dispatchEvent(new Event("eip6963:requestProvider"));
  });
}
async function waitForMetaMaskProvider(t, { timeout: e = 3e3, retries: n = 0 } = {}) {
  return detectMetaMaskProvider(t, { timeout: e }).catch(function() {
    return null;
  }).then(function(r) {
    return r || n === 0 ? r : waitForMetaMaskProvider(t, {
      timeout: e,
      retries: n - 1
    });
  });
}
async function detectMetamaskSupport(t) {
  return await waitForMetaMaskProvider(t, { retries: 3 });
}
async function fetchMetaMaskSnapWallet(t) {
  await init({
    name: "MetaMaskStarknetSnapWallet",
    remotes: [
      {
        name: "MetaMaskStarknetSnapWallet",
        alias: "MetaMaskStarknetSnapWallet",
        entry: "https://snaps.consensys.io/starknet/get-starknet/v1/remoteEntry.js"
      }
    ]
  });
  const e = await loadRemote("MetaMaskStarknetSnapWallet/index"), { MetaMaskSnapWallet: n } = e;
  return new n(t, "*");
}
function createMetaMaskProviderWrapper(t, e) {
  let n, r;
  return {
    id: t.id,
    name: t.name,
    icon: t.icon,
    get version() {
      var s;
      return (s = n == null ? void 0 : n.version) != null ? s : "0.0.0";
    },
    get isConnected() {
      var s;
      return (s = n == null ? void 0 : n.isConnected) != null ? s : !1;
    },
    get provider() {
      return n == null ? void 0 : n.provider;
    },
    get account() {
      return n == null ? void 0 : n.account;
    },
    get selectedAddress() {
      return n == null ? void 0 : n.selectedAddress;
    },
    get chainId() {
      return n == null ? void 0 : n.chainId;
    },
    request(s) {
      if (!n)
        throw new Error("Wallet not enabled");
      return n.request(s);
    },
    async enable() {
      return n || (r = r || fetchMetaMaskSnapWallet(e), n = await r), await n.enable();
    },
    isPreauthorized() {
      var s;
      return (s = n == null ? void 0 : n.isPreauthorized()) != null ? s : Promise.resolve(!1);
    },
    on(s, i) {
      if (!n)
        throw new Error("Wallet not enabled");
      return n.on(s, i);
    },
    off(s, i) {
      if (!n)
        throw new Error("Wallet not enabled");
      return n.off(s, i);
    }
  };
}
async function injectMetamaskBridge(t) {
  if (t.hasOwnProperty("starknet_metamask"))
    return;
  const e = wallets.find((r) => r.id === "metamask");
  if (!e)
    return;
  const n = await detectMetamaskSupport(t);
  !n || (t.starknet_metamask = createMetaMaskProviderWrapper(
    e,
    n
  ));
}
function scanObjectForWallets(t, e) {
  return Object.values(
    Object.getOwnPropertyNames(t).reduce((n, r) => {
      if (r.startsWith("starknet")) {
        const o = t[r];
        e(o) && !n[o.id] && (n[o.id] = o);
      }
      return n;
    }, {})
  );
}
const sortBy = (t, e) => {
  if (e && Array.isArray(e)) {
    t.sort((r, o) => e.indexOf(r.id) - e.indexOf(o.id));
    const n = t.length - e.length;
    return [
      ...t.slice(n),
      ...shuffle(t.slice(0, n))
    ];
  } else
    return shuffle(t);
}, defaultOptions = {
  windowObject: ssrSafeWindow != null ? ssrSafeWindow : {},
  isWalletObject: isWalletObj,
  storageFactoryImplementation: (t) => new LocalStorageWrapper(t)
};
function getStarknet(t = {}) {
  const { storageFactoryImplementation: e, windowObject: n, isWalletObject: r } = {
    ...defaultOptions,
    ...t
  }, o = e("gsw-last");
  return injectMetamaskBridge(n), {
    getAvailableWallets: async (s = {}) => {
      const i = scanObjectForWallets(
        n,
        r
      );
      return pipe$1(
        (a) => filterBy(a, s),
        (a) => sortBy(a, s.sort)
      )(i);
    },
    getPreAuthorizedWallets: async (s = {}) => {
      const i = scanObjectForWallets(
        n,
        r
      );
      return pipe$1(
        (a) => filterByPreAuthorized(a),
        (a) => filterBy(a, s),
        (a) => sortBy(a, s.sort)
      )(i);
    },
    getDiscoveryWallets: async (s = {}) => pipe$1(
      (i) => filterBy(i, s),
      (i) => sortBy(i, s.sort)
    )(wallets),
    getLastConnectedWallet: async () => {
      const s = o.get(), a = scanObjectForWallets(n, r).find(
        (c) => c.id === s
      ), [l] = await filterByPreAuthorized(
        a ? [a] : []
      );
      return l || (o.delete(), null);
    },
    enable: async (s, i) => {
      if (await s.enable(i != null ? i : { starknetVersion: "v5" }), !s.isConnected)
        throw new Error("Failed to connect to wallet");
      return o.set(s.id), s;
    },
    disconnect: async ({ clearLastWallet: s } = {}) => {
      s && o.delete();
    }
  };
}
const main = getStarknet();
export {
  main as default,
  getStarknet,
  ssrSafeWindow
};
